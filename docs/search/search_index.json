{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to EnergyFlow EnergyFlow is a Python package for computing Energy Flow Polynomials (EFPs), a collection of jet substructure observables which form a complete, linear basis of IRC-safe observables. The source code can be found on GitHub . The current version is 0.10.2 . We recommend that you use the most up-to-date version as things may change quickly. As of version 0.7.0 , tests have been written covering the majority of the EFP code. Get started by installing EnergyFlow and checking out the demo ! References [1] P.T. Komiske, E.M. Metodiev, and J. Thaler, Energy Flow Polynomials: A complete linear basis for jet substructure , JHEP 04 (2018) 013 [ 1712.07124 ].","title":"Home"},{"location":"#welcome-to-energyflow","text":"EnergyFlow is a Python package for computing Energy Flow Polynomials (EFPs), a collection of jet substructure observables which form a complete, linear basis of IRC-safe observables. The source code can be found on GitHub . The current version is 0.10.2 . We recommend that you use the most up-to-date version as things may change quickly. As of version 0.7.0 , tests have been written covering the majority of the EFP code. Get started by installing EnergyFlow and checking out the demo !","title":"Welcome to EnergyFlow"},{"location":"#references","text":"[1] P.T. Komiske, E.M. Metodiev, and J. Thaler, Energy Flow Polynomials: A complete linear basis for jet substructure , JHEP 04 (2018) 013 [ 1712.07124 ].","title":"References"},{"location":"faq/","text":"Frequently Asked EnergyFlow Questions How do I cite the EnergyFlow package? Why Python instead of C++? Can I contribute to the code? How do I report an issue or a bug? Where can I get graph image files? How do I cite the EnergyFlow package? Please cite the relevant Energy Flow papers if they or this package helps your research. Here are the BibTeX entries to use: @article{Komiske:2017aww, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Energy Flow Polynomials: A complete linear basis for jet substructure}\", journal = \"JHEP\", volume = \"04\", year = \"2018\", pages = \"013\", doi = \"10.1007/JHEP04(2018)013\", eprint = \"1712.07124\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP-4965\" } Why Python instead of C++? Computing the energy flow polynomials requires a function such as NumPy's einsum that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use. NumPy is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the energy flow polynomials. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and features such as SSE instructions. Can I contribute to the code? All of our code is open source and hosted on GitHub . We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository. How do I report an issue? Please let us know of any issues you encounter as soon as possible by creating an Issue on the EnergyFlow GitHub repository. Where can I get graph image files? Image files for all connected multigraphs with up to 7 edges in the energy flow polynomial style are available as pdf files here . You are free to use them with the proper attribution.","title":"FAQ"},{"location":"faq/#frequently-asked-energyflow-questions","text":"How do I cite the EnergyFlow package? Why Python instead of C++? Can I contribute to the code? How do I report an issue or a bug? Where can I get graph image files?","title":"Frequently Asked EnergyFlow Questions"},{"location":"faq/#how-do-i-cite-the-energyflow-package","text":"Please cite the relevant Energy Flow papers if they or this package helps your research. Here are the BibTeX entries to use: @article{Komiske:2017aww, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Energy Flow Polynomials: A complete linear basis for jet substructure}\", journal = \"JHEP\", volume = \"04\", year = \"2018\", pages = \"013\", doi = \"10.1007/JHEP04(2018)013\", eprint = \"1712.07124\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP-4965\" }","title":"How do I cite the EnergyFlow package?"},{"location":"faq/#why-python-instead-of-c","text":"Computing the energy flow polynomials requires a function such as NumPy's einsum that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use. NumPy is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the energy flow polynomials. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and features such as SSE instructions.","title":"Why Python instead of C++?"},{"location":"faq/#can-i-contribute-to-the-code","text":"All of our code is open source and hosted on GitHub . We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository.","title":"Can I contribute to the code?"},{"location":"faq/#how-do-i-report-an-issue","text":"Please let us know of any issues you encounter as soon as possible by creating an Issue on the EnergyFlow GitHub repository.","title":"How do I report an issue?"},{"location":"faq/#where-can-i-get-graph-image-files","text":"Image files for all connected multigraphs with up to 7 edges in the energy flow polynomial style are available as pdf files here . You are free to use them with the proper attribution.","title":"Where can I get graph image files?"},{"location":"installation/","text":"The EnergyFlow package is written in pure Python and depends only on NumPy, the fundamental package for scientific computing with Python, and six, which is a lightweight module to patch some inconvenient differences between Python 2 and Python 3. The EnergyFlow package is designed to work with Python 2.7, 3.5, and 3.6. These can be installed from here . The latest stable version of Python 3 is highly recommended. Install with pip (recommended) To install from PyPI using pip , make sure you have one of the supported versions of Python installed and that pip is available in the system path. Simply execute pip install energyflow and EnergyFlow will be installed in your default location for Python packages. Bleeding edge install EnergyFlow is hosted on GitHub and can be installed by cloning the repository and running python setup.py install . iGraph EnergyFlow relies on iGraph for generation of multigraphs. This is not required if using the provided graphs suits your needs. If you wish to generate your own graphs, make sure that iGraph is importable. NumPy Since EnergyFlow relies on numpy.einsum to do most of the computational heavy lifting, newer versions of NumPy may provide changes/speedups in performance if einsum changes. NumPy 1.14.0 changed einsum to use tensordot when possible compared to 1.13.3 , which only used c_einsum . This means that computations are faster on larger tensors but may be slower on smaller tensors. EnergyFlow currently uses only c_einsum because it was found to be substantially faster for typical pp-jet applications.","title":"Installation"},{"location":"installation/#install-with-pip-recommended","text":"To install from PyPI using pip , make sure you have one of the supported versions of Python installed and that pip is available in the system path. Simply execute pip install energyflow and EnergyFlow will be installed in your default location for Python packages.","title":"Install with pip (recommended)"},{"location":"installation/#bleeding-edge-install","text":"EnergyFlow is hosted on GitHub and can be installed by cloning the repository and running python setup.py install .","title":"Bleeding edge install"},{"location":"installation/#igraph","text":"EnergyFlow relies on iGraph for generation of multigraphs. This is not required if using the provided graphs suits your needs. If you wish to generate your own graphs, make sure that iGraph is importable.","title":"iGraph"},{"location":"installation/#numpy","text":"Since EnergyFlow relies on numpy.einsum to do most of the computational heavy lifting, newer versions of NumPy may provide changes/speedups in performance if einsum changes. NumPy 1.14.0 changed einsum to use tensordot when possible compared to 1.13.3 , which only used c_einsum . This means that computations are faster on larger tensors but may be slower on smaller tensors. EnergyFlow currently uses only c_einsum because it was found to be substantially faster for typical pp-jet applications.","title":"NumPy"},{"location":"tutorial/","text":"Jupyter Notebook Demo For an introduction to EnergyFlow, you can view or download a demo notebook here .","title":"Tutorial"},{"location":"tutorial/#jupyter-notebook-demo","text":"For an introduction to EnergyFlow, you can view or download a demo notebook here .","title":"Jupyter Notebook Demo"},{"location":"docs/efp/","text":"Energy Flow Polynomials (EFPs) are a set of observables, indexed by non-isomorphic multigraphs, which linearly span the space of infrared and collinear safe (IRC-safe) observables. An EFP index by a multigraph $G$ takes the following form: \\text{EFP}_G=\\sum_{i_1=1}^M\\cdots\\sum_{i_N=1}^Mz_{i_1}\\cdots z_{i_N} \\prod_{(k,\\ell)\\in G}\\theta_{i_ki_\\ell} where $z_i$ is a measure of the energy of particle $i$ and $\\theta_{ij}$ is a measure of the angular separation between particles $i$ and $j$. The specific choices for energy and angular measure depend on the collider context and are discussed at length in the Measures section. EFP A class for representing and computing a single EFP. energyflow.EFP(edges, measure='hadrdot', beta=1, kappa=1, normed=True, coords=None, check_input=True, ve_alg='numpy', np_optimize='greedy') Arguments edges : list Edges of the EFP graph specified by pairs of vertices. measure : { 'hadr' , 'hadrdot' , 'hadrefm' , 'ee' , 'eeefm' } See Measures for additional info. beta : float The parameter $\\beta$ appearing in the measure. Must be greater than zero. kappa : { float , 'pf' } If a number, the energy weighting parameter $\\kappa$. If 'pf' , use $\\kappa=v-1$ where $v$ is the valency of the vertex. normed : bool Controls normalization of the energies in the measure. check_input : bool Whether to check the type of the input each time or assume the first input type. ve_alg : { 'numpy' , 'ef' } Which variable elimination algorithm to use. np_optimize : { True , False , 'greedy' , 'optimal' } When ve_alg='numpy' this is the optimize keyword of numpy.einsum_path . compute compute(event=None, zs=None, thetas=None) Computes the value(s) of the EFP(s) on a single event. Arguments event : array_like or fastjet.PseudoJet The event as an array of [E,px,py,pz] or [pT,y,phi] (if hadronic). zs : 1-dim array_like If present, thetas must also be present, and zs is used in place of the energies of an event. thetas : 2-dim array_like If present, zs must also be present, and thetas is used in place of the pairwise angles of an event. ps : numpy.ndarray If present, used in place of the dim-vectors returned by the measure when using EFMs. Returns numpy.ndarray The answers batch_compute batch_compute(events, n_jobs=-1) Computes the value(s) of the EFP(s) on several events. Arguments events : array_like or fastjet.PseudoJet The events as an array of arrays of [E,px,py,pz] or [pT,y,phi] (if hadronic). n_jobs : int The number of worker processes to use. A value of -1 will attempt to use as many processes as there are CPUs on the machine. Returns numpy.ndarray The answers graph graph Graph of this EFP represented by a list of edges. simple_graph simple_graph Simple graph of this EFP (forgetting all multiedges) represented by a list of edges. n n Number of vertices in the graph of this EFP. d d Degree, or number of edges, in the graph of this EFP. c c VE complexity $\\chi$ of this EFP. EFPSet A class that holds a collection of EFPs and computes their values on events. energyflow.EFPSet(*args, filename=None, measure='hadrdot', beta=1, kappa=1, normed=True, check_input=True, verbose=False) EFPSet can be initialized in one of three ways (in order of precedence): Default - Use the EFPs that come installed with the EnergFlow package. Generator - Pass in a custom Generator object as the first positional argument. Custom File - Pass in the name of a .npz file saved with a custom Generator . To control which EFPs are included, EFPSet accepts an arbitrary number of specifications (see sel ) and only EFPs meeting each specification are included in the set. Arguments *args : arbitrary positional arguments If the first positional argument is a Generator instance, it is used for initialization. The remaining positional arguments must be valid arguments to sel . filename : string Path to a .npz file which has been saved by a valid energyflow.Generator . measure : { 'hadr' , 'hadr-dot' , 'ee' } See Measures for additional info. beta : float The parameter $\\beta$ appearing in the measure. Must be greater than zero. kappa : { float , 'pf' } If a number, the energy weighting parameter $\\kappa$. If 'pf' , use $\\kappa=v-1$ where $v$ is the valency of the vertex. normed : bool Controls normalization of the energies in the measure. check_type : bool Whether to check the type of the input each time or use the first input type. verbose : bool Controls printed output when initializing EFPSet. compute compute(event=None, zs=None, thetas=None, ps=None) Computes the value(s) of the EFP(s) on a single event. Arguments event : array_like or fastjet.PseudoJet The event as an array of [E,px,py,pz] or [pT,y,phi] (if hadronic). zs : 1-dim array_like If present, thetas must also be present, and zs is used in place of the energies of an event. thetas : 2-dim array_like If present, zs must also be present, and thetas is used in place of the pairwise angles of an event. ps : numpy.ndarray If present, used in place of the dim-vectors returned by the measure when using EFMs. Returns numpy.ndarray The answers batch_compute batch_compute(events, n_jobs=-1) Computes the value(s) of the EFP(s) on several events. Arguments events : array_like or fastjet.PseudoJet The events as an array of arrays of [E,px,py,pz] or [pT,y,phi] (if hadronic). n_jobs : int The number of worker processes to use. A value of -1 will attempt to use as many processes as there are CPUs on the machine. Returns numpy.ndarray The answers calc_disc calc_disc(X) Computes disconnected EFPs according to the internal specifications using the connected EFPs provided as input. Arguments X : numpy.ndarray Array of connected EFPs. Rows are different events, columns are the different EFPs. Can handle a single event (a 1-dim array) as input. EFPs are assumed to be in the order expected by the instance of EFPSet ; the safest way to ensure this is to use the same EFPSet to calculate both connected and disconnected EFPs. This function is used internally in compute and batch_compute . Returns numpy.ndarray A concatenated array of the connected and disconnected EFPs. sel sel(*args) Computes a boolean mask of EFPs matching each of the specifications provided by the args . Arguments *args : arbitrary positional arguments Each argument can be either a string or a length-two iterable. If the argument is a string, it should consist of three parts: a character which is a valid element of cols , a comparison operator (one of < , > , <= , >= , == , != ), and a number. Whitespace between the parts does not matter. If the argument is a tuple, the first element should be a string containing a column header character and a comparison operator; the second element is the value to be compared. The tuple version is useful when the value is a variable that changes (such as in a list comprehension). Returns numpy.ndarray A boolean array of length the number of EFPs stored by this object. count count(*args) Counts the number of EFPs meeting the specifications of the arguments using sel . Arguments *args : arbitrary positional arguments Valid arguments to be passed to sel . Returns int The number of EFPs meeting the specifications provided. graphs graphs(*args) Graphs meeting provided specifications. Arguments *args : arbitrary positional arguments Valid arguments to be passed to sel , or, if a single integer, the index of a particular graph. Returns list , if single integer argument is given The list of edges corresponding to the specified graph numpy.ndarray , otherwise An array of graphs (as lists of edges) matching the specifications. simple_graphs simple_graphs(*args) Simple graphs meeting provided specifications. Arguments *args : arbitrary positional arguments Valid arguments to be passed to sel , or, if a single integer, the index of particular simple graph. Returns list , if single integer argument is given The list of edges corresponding to the specified simple graph numpy.ndarray , otherwise An array of simple graphs (as lists of edges) matching the specifications. specs specs An array of EFP specifications. Each row represents an EFP and the columns represent the quantities indicated by cols . cspecs cspecs Specification array for connected EFPs. cols cols Column labels for specs . Those of primary interest are listed below. n : Number of vertices. e : Number of simple edges. d : Degree, or number of multiedges. v : Maximum valency (number of edges touching a vertex). k : Unique identifier within EFPs of this (n,d). c : VE complexity $\\chi$. p : Number of prime factors (or connected components). h : Number of valency 1 vertices (a.k.a. 'hanging chads').","title":"Energy Flow Polynomials"},{"location":"docs/efp/#efp","text":"A class for representing and computing a single EFP. energyflow.EFP(edges, measure='hadrdot', beta=1, kappa=1, normed=True, coords=None, check_input=True, ve_alg='numpy', np_optimize='greedy') Arguments edges : list Edges of the EFP graph specified by pairs of vertices. measure : { 'hadr' , 'hadrdot' , 'hadrefm' , 'ee' , 'eeefm' } See Measures for additional info. beta : float The parameter $\\beta$ appearing in the measure. Must be greater than zero. kappa : { float , 'pf' } If a number, the energy weighting parameter $\\kappa$. If 'pf' , use $\\kappa=v-1$ where $v$ is the valency of the vertex. normed : bool Controls normalization of the energies in the measure. check_input : bool Whether to check the type of the input each time or assume the first input type. ve_alg : { 'numpy' , 'ef' } Which variable elimination algorithm to use. np_optimize : { True , False , 'greedy' , 'optimal' } When ve_alg='numpy' this is the optimize keyword of numpy.einsum_path .","title":"EFP"},{"location":"docs/efp/#compute","text":"compute(event=None, zs=None, thetas=None) Computes the value(s) of the EFP(s) on a single event. Arguments event : array_like or fastjet.PseudoJet The event as an array of [E,px,py,pz] or [pT,y,phi] (if hadronic). zs : 1-dim array_like If present, thetas must also be present, and zs is used in place of the energies of an event. thetas : 2-dim array_like If present, zs must also be present, and thetas is used in place of the pairwise angles of an event. ps : numpy.ndarray If present, used in place of the dim-vectors returned by the measure when using EFMs. Returns numpy.ndarray The answers","title":"compute"},{"location":"docs/efp/#batch_compute","text":"batch_compute(events, n_jobs=-1) Computes the value(s) of the EFP(s) on several events. Arguments events : array_like or fastjet.PseudoJet The events as an array of arrays of [E,px,py,pz] or [pT,y,phi] (if hadronic). n_jobs : int The number of worker processes to use. A value of -1 will attempt to use as many processes as there are CPUs on the machine. Returns numpy.ndarray The answers","title":"batch_compute"},{"location":"docs/efp/#graph","text":"graph Graph of this EFP represented by a list of edges.","title":"graph"},{"location":"docs/efp/#simple_graph","text":"simple_graph Simple graph of this EFP (forgetting all multiedges) represented by a list of edges.","title":"simple_graph"},{"location":"docs/efp/#n","text":"n Number of vertices in the graph of this EFP.","title":"n"},{"location":"docs/efp/#d","text":"d Degree, or number of edges, in the graph of this EFP.","title":"d"},{"location":"docs/efp/#c","text":"c VE complexity $\\chi$ of this EFP.","title":"c"},{"location":"docs/efp/#efpset","text":"A class that holds a collection of EFPs and computes their values on events. energyflow.EFPSet(*args, filename=None, measure='hadrdot', beta=1, kappa=1, normed=True, check_input=True, verbose=False) EFPSet can be initialized in one of three ways (in order of precedence): Default - Use the EFPs that come installed with the EnergFlow package. Generator - Pass in a custom Generator object as the first positional argument. Custom File - Pass in the name of a .npz file saved with a custom Generator . To control which EFPs are included, EFPSet accepts an arbitrary number of specifications (see sel ) and only EFPs meeting each specification are included in the set. Arguments *args : arbitrary positional arguments If the first positional argument is a Generator instance, it is used for initialization. The remaining positional arguments must be valid arguments to sel . filename : string Path to a .npz file which has been saved by a valid energyflow.Generator . measure : { 'hadr' , 'hadr-dot' , 'ee' } See Measures for additional info. beta : float The parameter $\\beta$ appearing in the measure. Must be greater than zero. kappa : { float , 'pf' } If a number, the energy weighting parameter $\\kappa$. If 'pf' , use $\\kappa=v-1$ where $v$ is the valency of the vertex. normed : bool Controls normalization of the energies in the measure. check_type : bool Whether to check the type of the input each time or use the first input type. verbose : bool Controls printed output when initializing EFPSet.","title":"EFPSet"},{"location":"docs/efp/#compute_1","text":"compute(event=None, zs=None, thetas=None, ps=None) Computes the value(s) of the EFP(s) on a single event. Arguments event : array_like or fastjet.PseudoJet The event as an array of [E,px,py,pz] or [pT,y,phi] (if hadronic). zs : 1-dim array_like If present, thetas must also be present, and zs is used in place of the energies of an event. thetas : 2-dim array_like If present, zs must also be present, and thetas is used in place of the pairwise angles of an event. ps : numpy.ndarray If present, used in place of the dim-vectors returned by the measure when using EFMs. Returns numpy.ndarray The answers","title":"compute"},{"location":"docs/efp/#batch_compute_1","text":"batch_compute(events, n_jobs=-1) Computes the value(s) of the EFP(s) on several events. Arguments events : array_like or fastjet.PseudoJet The events as an array of arrays of [E,px,py,pz] or [pT,y,phi] (if hadronic). n_jobs : int The number of worker processes to use. A value of -1 will attempt to use as many processes as there are CPUs on the machine. Returns numpy.ndarray The answers","title":"batch_compute"},{"location":"docs/efp/#calc_disc","text":"calc_disc(X) Computes disconnected EFPs according to the internal specifications using the connected EFPs provided as input. Arguments X : numpy.ndarray Array of connected EFPs. Rows are different events, columns are the different EFPs. Can handle a single event (a 1-dim array) as input. EFPs are assumed to be in the order expected by the instance of EFPSet ; the safest way to ensure this is to use the same EFPSet to calculate both connected and disconnected EFPs. This function is used internally in compute and batch_compute . Returns numpy.ndarray A concatenated array of the connected and disconnected EFPs.","title":"calc_disc"},{"location":"docs/efp/#sel","text":"sel(*args) Computes a boolean mask of EFPs matching each of the specifications provided by the args . Arguments *args : arbitrary positional arguments Each argument can be either a string or a length-two iterable. If the argument is a string, it should consist of three parts: a character which is a valid element of cols , a comparison operator (one of < , > , <= , >= , == , != ), and a number. Whitespace between the parts does not matter. If the argument is a tuple, the first element should be a string containing a column header character and a comparison operator; the second element is the value to be compared. The tuple version is useful when the value is a variable that changes (such as in a list comprehension). Returns numpy.ndarray A boolean array of length the number of EFPs stored by this object.","title":"sel"},{"location":"docs/efp/#count","text":"count(*args) Counts the number of EFPs meeting the specifications of the arguments using sel . Arguments *args : arbitrary positional arguments Valid arguments to be passed to sel . Returns int The number of EFPs meeting the specifications provided.","title":"count"},{"location":"docs/efp/#graphs","text":"graphs(*args) Graphs meeting provided specifications. Arguments *args : arbitrary positional arguments Valid arguments to be passed to sel , or, if a single integer, the index of a particular graph. Returns list , if single integer argument is given The list of edges corresponding to the specified graph numpy.ndarray , otherwise An array of graphs (as lists of edges) matching the specifications.","title":"graphs"},{"location":"docs/efp/#simple_graphs","text":"simple_graphs(*args) Simple graphs meeting provided specifications. Arguments *args : arbitrary positional arguments Valid arguments to be passed to sel , or, if a single integer, the index of particular simple graph. Returns list , if single integer argument is given The list of edges corresponding to the specified simple graph numpy.ndarray , otherwise An array of simple graphs (as lists of edges) matching the specifications.","title":"simple_graphs"},{"location":"docs/efp/#specs","text":"specs An array of EFP specifications. Each row represents an EFP and the columns represent the quantities indicated by cols .","title":"specs"},{"location":"docs/efp/#cspecs","text":"cspecs Specification array for connected EFPs.","title":"cspecs"},{"location":"docs/efp/#cols","text":"cols Column labels for specs . Those of primary interest are listed below. n : Number of vertices. e : Number of simple edges. d : Degree, or number of multiedges. v : Maximum valency (number of edges touching a vertex). k : Unique identifier within EFPs of this (n,d). c : VE complexity $\\chi$. p : Number of prime factors (or connected components). h : Number of valency 1 vertices (a.k.a. 'hanging chads').","title":"cols"},{"location":"docs/gen/","text":"Implementation of EFP Generator class. Generator Generates non-isomorphic multigraphs according to provided specifications. energyflow.Generator(dmax=None, nmax=None, emax=None, cmax=None, vmax=None, comp_dmaxs=None, filename=None, ve_alg='numpy', np_optimize='greedy', verbose=False) Doing a fresh generation of connected multigraphs ( filename=None ) requires that igraph be installed. Arguments dmax : int The maximum number of edges of the generated connected graphs. nmax : int The maximum number of vertices of the generated connected graphs. emax : int The maximum number of edges of the generated connected simple graphs. cmax : int The maximum VE complexity $\\chi$ of the generated connected graphs. vmax : int The maximum valency of the generated connected graphs. comp_dmaxs : { dict , int } If an integer, the maximum number of edges of the generated disconnected graphs. If a dictionary, the keys are numbers of vertices and the values are the maximum number of edges of the generated disconnected graphs with that number of vertices. filename : str If None , do a complete generation from scratch. If set to a string, read in connected graphs from the file given, restrict them according to the various 'max' parameters, and do a fresh disconnected generation. The special value filename='default' means to read in graphs from the default file. This is useful when various disconnected graph parameters are to be varied since the generation of large simple graphs is the most computationlly intensive part. ve_alg : { 'numpy' , 'ef' } Which variable elimination algorithm to use. np_optimize : { True , False , 'greedy' , 'optimal' } When ve_alg='numpy' this is the optimize keyword of numpy.einsum_path . verbose : bool A flag to control printing. save save(filename) Save the current generator to file. Arguments filename : str The path to save the file. specs specs An array of EFP specifications. Each row represents an EFP and the columns represent the quantities indicated by cols .","title":"Generation"},{"location":"docs/gen/#generator","text":"Generates non-isomorphic multigraphs according to provided specifications. energyflow.Generator(dmax=None, nmax=None, emax=None, cmax=None, vmax=None, comp_dmaxs=None, filename=None, ve_alg='numpy', np_optimize='greedy', verbose=False) Doing a fresh generation of connected multigraphs ( filename=None ) requires that igraph be installed. Arguments dmax : int The maximum number of edges of the generated connected graphs. nmax : int The maximum number of vertices of the generated connected graphs. emax : int The maximum number of edges of the generated connected simple graphs. cmax : int The maximum VE complexity $\\chi$ of the generated connected graphs. vmax : int The maximum valency of the generated connected graphs. comp_dmaxs : { dict , int } If an integer, the maximum number of edges of the generated disconnected graphs. If a dictionary, the keys are numbers of vertices and the values are the maximum number of edges of the generated disconnected graphs with that number of vertices. filename : str If None , do a complete generation from scratch. If set to a string, read in connected graphs from the file given, restrict them according to the various 'max' parameters, and do a fresh disconnected generation. The special value filename='default' means to read in graphs from the default file. This is useful when various disconnected graph parameters are to be varied since the generation of large simple graphs is the most computationlly intensive part. ve_alg : { 'numpy' , 'ef' } Which variable elimination algorithm to use. np_optimize : { True , False , 'greedy' , 'optimal' } When ve_alg='numpy' this is the optimize keyword of numpy.einsum_path . verbose : bool A flag to control printing.","title":"Generator"},{"location":"docs/gen/#save","text":"save(filename) Save the current generator to file. Arguments filename : str The path to save the file.","title":"save"},{"location":"docs/gen/#specs","text":"specs An array of EFP specifications. Each row represents an EFP and the columns represent the quantities indicated by cols .","title":"specs"},{"location":"docs/measure/","text":"Energy and Angular Measures The appropriate notions of energy and angle depend on the collider context. Typically, one wants to work with observables that respect the appropriate Lorentz subgroup for the collision type of interest. EnergyFlow is capable of handling two broad classes of measures: $e^+e^-$ and hadronic, which are selected using the measure keyword argument (default is 'hadrdot' ). For substructure applications, it is often convenient to normalize the energies so that $\\sum_iz_i=1$. The normed keyword argument is provided to control normalization of the energies (default is True ). Each measure comes with a parameter $\\beta>0$ which controls the relative weighting between smaller and larger anglular structures. This can be set using the beta keyword argument (default is 2 ). There is also a $\\kappa$ parameter to control the relative weighting between soft and hard energies. This can be set using the kappa keyword argument (default is 1 ). Only kappa=1 yields collinear-safe observables. Beyond the measures implemented here, the user can implement their own custom measure by passing ${z_i}$ and ${\\theta_{ij}}$ in directly to the EFP classes. Hadronic Measures For hadronic collisions, observables are typically desired to be invariant under boosts along the beam direction and rotations about the beam direction. Thus, particle transverse momentum $p_T$ and rapidity-azimuth coordinates $(y,\\phi)$ are often used. There are two hadronic measures implemented in EnergyFlow: 'hadr' and 'hadrdot' (the default). These are listed explicitly below. 'hadr' : z_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=(\\Delta y_{ij}^2 + \\Delta\\phi_{ij}^2)^{\\beta/2}. 'hadrdot' : z_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=\\left(\\frac{2p^\\mu_ip_{j\\mu}}{p_{T,i}p_{T,j}} \\right)^{\\beta/2}. e+e- Measures For $e^+e^-$ collisions, observables are typically desired to be invariant under the full group of reotations about the interaction point. Since the center of momentum energy is known, the particle energy $E$ is typically used. For the angular measure, pairwise Lorentz contractions of the normalized particle four-momenta are used. There is one $e^+e^-$ measure implemented in the EnergyFlow framework. 'ee' : z_i = E_{i}^{\\kappa}, \\quad\\quad \\theta_{ij} = \\left(\\frac{2p_i^\\mu p_{j \\mu}}{E_i E_j}\\right)^{\\beta/2}. Measure Class for dealing with any kind of measure. energyflow.Measure(measure, beta=1, kappa=1, normed=True, coords=None, check_input=True) Processes inputs according to the measure choice. Arguments measure : string The string specifying the energy and angular measures to use. beta : float or 'pf' The angular weighting exponent $\\beta$. Must be positive. kappa : float If a number, the energy weighting exponent $\\kappa$. If 'pf' , use $\\kappa=v$ where $v$ is the valency of the vertex. 'pf' can be used with measure except 'hadr' . Only IRC-safe for kappa=1 . normed : bool Whether or not to use normalized energies check_input : bool Whether to check the type of input each time or assume the first input type. evaluate evaluate(arg) Evaluate","title":"Measures"},{"location":"docs/measure/#energy-and-angular-measures","text":"The appropriate notions of energy and angle depend on the collider context. Typically, one wants to work with observables that respect the appropriate Lorentz subgroup for the collision type of interest. EnergyFlow is capable of handling two broad classes of measures: $e^+e^-$ and hadronic, which are selected using the measure keyword argument (default is 'hadrdot' ). For substructure applications, it is often convenient to normalize the energies so that $\\sum_iz_i=1$. The normed keyword argument is provided to control normalization of the energies (default is True ). Each measure comes with a parameter $\\beta>0$ which controls the relative weighting between smaller and larger anglular structures. This can be set using the beta keyword argument (default is 2 ). There is also a $\\kappa$ parameter to control the relative weighting between soft and hard energies. This can be set using the kappa keyword argument (default is 1 ). Only kappa=1 yields collinear-safe observables. Beyond the measures implemented here, the user can implement their own custom measure by passing ${z_i}$ and ${\\theta_{ij}}$ in directly to the EFP classes.","title":"Energy and Angular Measures"},{"location":"docs/measure/#hadronic-measures","text":"For hadronic collisions, observables are typically desired to be invariant under boosts along the beam direction and rotations about the beam direction. Thus, particle transverse momentum $p_T$ and rapidity-azimuth coordinates $(y,\\phi)$ are often used. There are two hadronic measures implemented in EnergyFlow: 'hadr' and 'hadrdot' (the default). These are listed explicitly below. 'hadr' : z_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=(\\Delta y_{ij}^2 + \\Delta\\phi_{ij}^2)^{\\beta/2}. 'hadrdot' : z_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=\\left(\\frac{2p^\\mu_ip_{j\\mu}}{p_{T,i}p_{T,j}} \\right)^{\\beta/2}.","title":"Hadronic Measures"},{"location":"docs/measure/#ee-measures","text":"For $e^+e^-$ collisions, observables are typically desired to be invariant under the full group of reotations about the interaction point. Since the center of momentum energy is known, the particle energy $E$ is typically used. For the angular measure, pairwise Lorentz contractions of the normalized particle four-momenta are used. There is one $e^+e^-$ measure implemented in the EnergyFlow framework. 'ee' : z_i = E_{i}^{\\kappa}, \\quad\\quad \\theta_{ij} = \\left(\\frac{2p_i^\\mu p_{j \\mu}}{E_i E_j}\\right)^{\\beta/2}.","title":"e+e- Measures"},{"location":"docs/measure/#measure","text":"Class for dealing with any kind of measure. energyflow.Measure(measure, beta=1, kappa=1, normed=True, coords=None, check_input=True) Processes inputs according to the measure choice. Arguments measure : string The string specifying the energy and angular measures to use. beta : float or 'pf' The angular weighting exponent $\\beta$. Must be positive. kappa : float If a number, the energy weighting exponent $\\kappa$. If 'pf' , use $\\kappa=v$ where $v$ is the valency of the vertex. 'pf' can be used with measure except 'hadr' . Only IRC-safe for kappa=1 . normed : bool Whether or not to use normalized energies check_input : bool Whether to check the type of input each time or assume the first input type.","title":"Measure"},{"location":"docs/measure/#evaluate","text":"evaluate(arg) Evaluate","title":"evaluate"},{"location":"docs/utils/","text":"Particle Tools Tools to compute particle kinematic quantities from four-vectors, such as transverse momentum $p_T$, rapidity $y$, and azimuthal angle $\\phi$. Also includes functions for converting between Euclidean four-momenta and $(p_T,y,\\phi,[m])$. flat_metric energyflow.flat_metric(dim) The Minkowski metric in dim spacetime dimensions in the mostly-minus convention. Arguments dim : int The number of spacetime dimensions (thought to be four in our universe). Returns numpy.ndarray A dim -length, one-dimensional (not matrix) array equal to [+1, -1, ..., -1] p4s_from_ptyphims energyflow.p4s_from_ptyphims(ptyphims) Calculate Euclidean four-vectors from transverse momentum, rapidity, azimuthal angle, and (optionally) mass for each input. Arguments ptyphims : numpy.ndarray or list An array with shape (M, 4) of [pT, y, phi, m] for each particle. An array with shape (M, 3) is also accepted where the masses are taken to be zero. A single particle is also accepted. Returns numpy.ndarray An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. If a single particle was given as input, a single four-vector will be returned. p4s_from_ptyphis energyflow.p4s_from_ptyphis(ptyphis) Calculate Euclidean four-vectors from transverse momentum, rapidity, and azimuthal angle. Particles are taken to be massless. Arguments ptyphims : numpy.ndarray or list An array with shape (M, 3) of [pT, y, phi] for each particle. A single particle is also accepted. Returns numpy.ndarray An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. If a single particle was given as input, a single four-vector will be returned. pts_from_p4s energyflow.pts_from_p4s(p4s) Calculate the transverse momenta of a collection of four-vectors Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the transverse momentum of each particle. If a single particle was given as input, a single float is returned. ys_from_p4s energyflow.ys_from_p4s(p4s) Calculate the rapidities of a collection of four-vectors Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the rapidity of each particle. If a single particle was given as input, a single float is returned. phi_fix energyflow.phi_fix(phis, phi_ref, copy=False) A function to ensure that all phi values are within $\\pi$ of phi_ref . It is assumed that all starting phi values are within $2\\pi$ of phi_ref . Arguments phis : numpy.ndarray or list One-dimensional array of phi values. phi_ref : float A reference value used so that all phis will be within $\\pm\\pi$ of this value. copy : bool Determines if phis are copied or not. If False then phis may be modified in place. Returns numpy.ndarray An array of the fixed phi values. phis_from_p4s energyflow.phis_from_p4s(p4s, phi_ref=None) Calculate the azimuthal angles of a collection of four-vectors. If phi_ref is not None , then phi_fix is called using this value. Otherwise, the angles are chosen to be in the inverval $[0,2\\pi]$. Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. phi_ref : float See Returns numpy.ndarray or list An M -length array consisting of the azimuthal angle of each particle. If a single particle was given as input, a single float is returned. ms_from_p4s energyflow.ms_from_p4s(p4s) Calculate the masses of a collection of four-vectors. Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the mass of each particle. If a single particle was given as input, a single float is returned. ptyphims_from_p4s energyflow.ptyphims_from_p4s(p4s, phi_ref=None, keep_shape=True) Compute the $(p_T,y,\\phi,m)$ representation of a four-vector for each Euclidean four-vector given as input. All-zero four-vectors are removed unless keep_shape is True . Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. phi_ref : float A reference value used so that all phis will be within $\\pm\\pi$ of thie value. keep_shape : bool Flag to determine if all-zero four-vectors will be retained. This is useful for keeping the shape of an array. Returns numpy.ndarray An array of size (M, 4) consisting of the transverse momentum, rapidity, azimuthal angle, and mass of each particle. If a single particle was given as input, a one-dimensional array is returned. Test Event Generation Functions to generate random sets of four-vectors. Includes an implementation of the RAMBO algorithm for sampling uniform M-body massless phase space. Also includes other functions for various random, non-center of momentum, and non-uniform sampling. gen_massless_phase_space energyflow.gen_massless_phase_space(nevents, nparticles, energy=1) Implementation of the RAMBO algorithm for uniformly sampling massless M-body phase space for any center of mass energies. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. energy : float Total center of mass energy of each event. Returns numpy.ndarray An ( nevents , nparticles , 4) array of events, each with nparticles massless particles and center of mass energy equal to energy . gen_random_events energyflow.gen_random_events(nevents, nparticles, dim=4, mass=0) Generate random events with a given number of particles of a given mass in a given spacetime dimension. The energy-momentum vectors have spatial components drawn randomly from [-1,+1]. These events are not guaranteed to uniformly sample phase space. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. dim : int Number of spacetime dimensions. mass : float Mass of the particles to generate. Returns numpy.ndarray An ( nevents , nparticles , dim ) array of events, each with nparticles particles with mass given by mass . gen_random_events_massless_com energyflow.gen_random_events_massless_com(nevents, nparticles, dim=4) Generate random events with a given number of massless particles in a given spacetime dimension. The total energy and momentum are made to sum to zero by making about half of the particles incoming. These events are not guaranteed to uniformly sample phase space. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. dim : int Number of spacetime dimensions. Returns numpy.ndarray An ( nevents , nparticles , dim ) array of events, each with nparticles massless particles whose total energy and momentum are all zero. mass2 energyflow.mass2(events) Compute the squared masses of every particle in events with any-dimensional energy-momentum vectors. Arguments events : numpy.ndarray Events as an ( nevents , M , dim ) array of dim-vectors [p0, p1, ..., pdim-1] for each particle. Returns numpy.ndarray An ( nevents , M ) array of calculated particle masses. Functions for dealing with datasets. URL handling and hashing functions copied from Keras GitHub repo. The required license and copyright notice are included below. COPYRIGHT All contributions by Francois Chollet: Copyright (c) 2015 - 2018, Francois Chollet. All rights reserved. All contributions by Google: Copyright (c) 2015 - 2018, Google, Inc. All rights reserved. All contributions by Microsoft: Copyright (c) 2017 - 2018, Microsoft, Inc. All rights reserved. All other contributions: Copyright (c) 2015 - 2018, the respective contributors. All rights reserved. Each contributor holds copyright over their respective contributions. The project versioning (Git) records all such contribution source information. LICENSE The MIT License (MIT) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. data_split energyflow.data_split(args, kwargs) A function to split an arbitrary number of arrays into train, validation, and test sets. If val_frac = 0, then we don't split any events into the validation set. If exactly two arguments are given (an \"X\" and \"Y\") then we return (X_train, [X_val], X_test, Y_train, [Y_val], Y_test), otherwise i lists corresponding to the different args are returned with each list being [train, [val], test]. Note that all arguments must have the same number of samples otherwise an exception will be raised. get_examples energyflow.get_examples(which='all', path='~/.energyflow') Pulls examples from GitHub. get_file energyflow.thefollowingfunctioniscloselybasedonthematchingKerasfunction Pulls file from the internet. pixelate energyflow.pixelate(jet, npix=33, img_width=0.8, nb_chan=1, charged_counts_only=False, norm=True) A function for creating a jet image from a list of particles. jet: an array containing the list of particles in a jet with each row representing a particle and the columns being (rapidity, phi, pT, pdgid), the latter not being necessary for a grayscale image. npix: number of pixels along one dimension of the image. img_width: the image will be size img_width x img_width nb_chan: 1 - returns a grayscale image of total pt 2 - returns a two-channel image with total pt and total counts norm: whether to normalize the pT channels to 1 according to the L1 norm remap_pids energyflow.remap_pids(events, pid_i=3) Remaps PDG id numbers to small floats. standardize energyflow.standardize(args, kwargs) Normalizes each argument by the standard deviation of the pixels in arg[0]. The expected use case would be standardize(X_train, X_val, X_test). channels: which channels to zero_center. The default will lead to all channels being affected. copy: if True, the arguments are unaffected. if False, the arguments themselves may be modified reg: used to prevent divide by zero to_categorical energyflow.to_categorical(vector, num_classes=None) One-hot encodes class labels. zero_center energyflow.zero_center(args, kwargs) Subtracts the mean of arg[0,channels] from the other arguments. Assumes that the arguments are numpy arrays. The expected use case would be zero_center(X_train, X_val, X_test). channels: list of which channels to zero_center. The default will lead to all channels being affected. copy: if True, the arguments are unaffected. if False, the arguments themselves may be modified","title":"Utils"},{"location":"docs/utils/#particle-tools","text":"Tools to compute particle kinematic quantities from four-vectors, such as transverse momentum $p_T$, rapidity $y$, and azimuthal angle $\\phi$. Also includes functions for converting between Euclidean four-momenta and $(p_T,y,\\phi,[m])$.","title":"Particle Tools"},{"location":"docs/utils/#flat_metric","text":"energyflow.flat_metric(dim) The Minkowski metric in dim spacetime dimensions in the mostly-minus convention. Arguments dim : int The number of spacetime dimensions (thought to be four in our universe). Returns numpy.ndarray A dim -length, one-dimensional (not matrix) array equal to [+1, -1, ..., -1]","title":"flat_metric"},{"location":"docs/utils/#p4s_from_ptyphims","text":"energyflow.p4s_from_ptyphims(ptyphims) Calculate Euclidean four-vectors from transverse momentum, rapidity, azimuthal angle, and (optionally) mass for each input. Arguments ptyphims : numpy.ndarray or list An array with shape (M, 4) of [pT, y, phi, m] for each particle. An array with shape (M, 3) is also accepted where the masses are taken to be zero. A single particle is also accepted. Returns numpy.ndarray An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. If a single particle was given as input, a single four-vector will be returned.","title":"p4s_from_ptyphims"},{"location":"docs/utils/#p4s_from_ptyphis","text":"energyflow.p4s_from_ptyphis(ptyphis) Calculate Euclidean four-vectors from transverse momentum, rapidity, and azimuthal angle. Particles are taken to be massless. Arguments ptyphims : numpy.ndarray or list An array with shape (M, 3) of [pT, y, phi] for each particle. A single particle is also accepted. Returns numpy.ndarray An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. If a single particle was given as input, a single four-vector will be returned.","title":"p4s_from_ptyphis"},{"location":"docs/utils/#pts_from_p4s","text":"energyflow.pts_from_p4s(p4s) Calculate the transverse momenta of a collection of four-vectors Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the transverse momentum of each particle. If a single particle was given as input, a single float is returned.","title":"pts_from_p4s"},{"location":"docs/utils/#ys_from_p4s","text":"energyflow.ys_from_p4s(p4s) Calculate the rapidities of a collection of four-vectors Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the rapidity of each particle. If a single particle was given as input, a single float is returned.","title":"ys_from_p4s"},{"location":"docs/utils/#phi_fix","text":"energyflow.phi_fix(phis, phi_ref, copy=False) A function to ensure that all phi values are within $\\pi$ of phi_ref . It is assumed that all starting phi values are within $2\\pi$ of phi_ref . Arguments phis : numpy.ndarray or list One-dimensional array of phi values. phi_ref : float A reference value used so that all phis will be within $\\pm\\pi$ of this value. copy : bool Determines if phis are copied or not. If False then phis may be modified in place. Returns numpy.ndarray An array of the fixed phi values.","title":"phi_fix"},{"location":"docs/utils/#phis_from_p4s","text":"energyflow.phis_from_p4s(p4s, phi_ref=None) Calculate the azimuthal angles of a collection of four-vectors. If phi_ref is not None , then phi_fix is called using this value. Otherwise, the angles are chosen to be in the inverval $[0,2\\pi]$. Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. phi_ref : float See Returns numpy.ndarray or list An M -length array consisting of the azimuthal angle of each particle. If a single particle was given as input, a single float is returned.","title":"phis_from_p4s"},{"location":"docs/utils/#ms_from_p4s","text":"energyflow.ms_from_p4s(p4s) Calculate the masses of a collection of four-vectors. Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the mass of each particle. If a single particle was given as input, a single float is returned.","title":"ms_from_p4s"},{"location":"docs/utils/#ptyphims_from_p4s","text":"energyflow.ptyphims_from_p4s(p4s, phi_ref=None, keep_shape=True) Compute the $(p_T,y,\\phi,m)$ representation of a four-vector for each Euclidean four-vector given as input. All-zero four-vectors are removed unless keep_shape is True . Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. phi_ref : float A reference value used so that all phis will be within $\\pm\\pi$ of thie value. keep_shape : bool Flag to determine if all-zero four-vectors will be retained. This is useful for keeping the shape of an array. Returns numpy.ndarray An array of size (M, 4) consisting of the transverse momentum, rapidity, azimuthal angle, and mass of each particle. If a single particle was given as input, a one-dimensional array is returned.","title":"ptyphims_from_p4s"},{"location":"docs/utils/#test-event-generation","text":"Functions to generate random sets of four-vectors. Includes an implementation of the RAMBO algorithm for sampling uniform M-body massless phase space. Also includes other functions for various random, non-center of momentum, and non-uniform sampling.","title":"Test Event Generation"},{"location":"docs/utils/#gen_massless_phase_space","text":"energyflow.gen_massless_phase_space(nevents, nparticles, energy=1) Implementation of the RAMBO algorithm for uniformly sampling massless M-body phase space for any center of mass energies. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. energy : float Total center of mass energy of each event. Returns numpy.ndarray An ( nevents , nparticles , 4) array of events, each with nparticles massless particles and center of mass energy equal to energy .","title":"gen_massless_phase_space"},{"location":"docs/utils/#gen_random_events","text":"energyflow.gen_random_events(nevents, nparticles, dim=4, mass=0) Generate random events with a given number of particles of a given mass in a given spacetime dimension. The energy-momentum vectors have spatial components drawn randomly from [-1,+1]. These events are not guaranteed to uniformly sample phase space. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. dim : int Number of spacetime dimensions. mass : float Mass of the particles to generate. Returns numpy.ndarray An ( nevents , nparticles , dim ) array of events, each with nparticles particles with mass given by mass .","title":"gen_random_events"},{"location":"docs/utils/#gen_random_events_massless_com","text":"energyflow.gen_random_events_massless_com(nevents, nparticles, dim=4) Generate random events with a given number of massless particles in a given spacetime dimension. The total energy and momentum are made to sum to zero by making about half of the particles incoming. These events are not guaranteed to uniformly sample phase space. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. dim : int Number of spacetime dimensions. Returns numpy.ndarray An ( nevents , nparticles , dim ) array of events, each with nparticles massless particles whose total energy and momentum are all zero.","title":"gen_random_events_massless_com"},{"location":"docs/utils/#mass2","text":"energyflow.mass2(events) Compute the squared masses of every particle in events with any-dimensional energy-momentum vectors. Arguments events : numpy.ndarray Events as an ( nevents , M , dim ) array of dim-vectors [p0, p1, ..., pdim-1] for each particle. Returns numpy.ndarray An ( nevents , M ) array of calculated particle masses. Functions for dealing with datasets. URL handling and hashing functions copied from Keras GitHub repo. The required license and copyright notice are included below. COPYRIGHT All contributions by Francois Chollet: Copyright (c) 2015 - 2018, Francois Chollet. All rights reserved. All contributions by Google: Copyright (c) 2015 - 2018, Google, Inc. All rights reserved. All contributions by Microsoft: Copyright (c) 2017 - 2018, Microsoft, Inc. All rights reserved. All other contributions: Copyright (c) 2015 - 2018, the respective contributors. All rights reserved. Each contributor holds copyright over their respective contributions. The project versioning (Git) records all such contribution source information. LICENSE The MIT License (MIT) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"mass2"},{"location":"docs/utils/#data_split","text":"energyflow.data_split(args, kwargs) A function to split an arbitrary number of arrays into train, validation, and test sets. If val_frac = 0, then we don't split any events into the validation set. If exactly two arguments are given (an \"X\" and \"Y\") then we return (X_train, [X_val], X_test, Y_train, [Y_val], Y_test), otherwise i lists corresponding to the different args are returned with each list being [train, [val], test]. Note that all arguments must have the same number of samples otherwise an exception will be raised.","title":"data_split"},{"location":"docs/utils/#get_examples","text":"energyflow.get_examples(which='all', path='~/.energyflow') Pulls examples from GitHub.","title":"get_examples"},{"location":"docs/utils/#get_file","text":"energyflow.thefollowingfunctioniscloselybasedonthematchingKerasfunction Pulls file from the internet.","title":"get_file"},{"location":"docs/utils/#pixelate","text":"energyflow.pixelate(jet, npix=33, img_width=0.8, nb_chan=1, charged_counts_only=False, norm=True) A function for creating a jet image from a list of particles. jet: an array containing the list of particles in a jet with each row representing a particle and the columns being (rapidity, phi, pT, pdgid), the latter not being necessary for a grayscale image. npix: number of pixels along one dimension of the image. img_width: the image will be size img_width x img_width nb_chan: 1 - returns a grayscale image of total pt 2 - returns a two-channel image with total pt and total counts norm: whether to normalize the pT channels to 1 according to the L1 norm","title":"pixelate"},{"location":"docs/utils/#remap_pids","text":"energyflow.remap_pids(events, pid_i=3) Remaps PDG id numbers to small floats.","title":"remap_pids"},{"location":"docs/utils/#standardize","text":"energyflow.standardize(args, kwargs) Normalizes each argument by the standard deviation of the pixels in arg[0]. The expected use case would be standardize(X_train, X_val, X_test). channels: which channels to zero_center. The default will lead to all channels being affected. copy: if True, the arguments are unaffected. if False, the arguments themselves may be modified reg: used to prevent divide by zero","title":"standardize"},{"location":"docs/utils/#to_categorical","text":"energyflow.to_categorical(vector, num_classes=None) One-hot encodes class labels.","title":"to_categorical"},{"location":"docs/utils/#zero_center","text":"energyflow.zero_center(args, kwargs) Subtracts the mean of arg[0,channels] from the other arguments. Assumes that the arguments are numpy arrays. The expected use case would be zero_center(X_train, X_val, X_test). channels: list of which channels to zero_center. The default will lead to all channels being affected. copy: if True, the arguments are unaffected. if False, the arguments themselves may be modified","title":"zero_center"}]}