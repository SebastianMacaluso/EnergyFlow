{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to EnergyFlow EnergyFlow is a Python package for computing Energy Flow Polynomials (EFPs), a collection of jet substructure observables which form a complete, linear basis of IRC-safe observables. The source code can be found on GitHub . The current version is 0.10.2 . We recommend that you use the most up-to-date version as things may change quickly. As of version 0.7.0 , tests have been written covering the majority of the EFP code. Get started by installing EnergyFlow and checking out the demo ! References [1] P.T. Komiske, E.M. Metodiev, and J. Thaler, Energy Flow Polynomials: A complete linear basis for jet substructure , JHEP 04 (2018) 013 [ 1712.07124 ].","title":"Home"},{"location":"#welcome-to-energyflow","text":"EnergyFlow is a Python package for computing Energy Flow Polynomials (EFPs), a collection of jet substructure observables which form a complete, linear basis of IRC-safe observables. The source code can be found on GitHub . The current version is 0.10.2 . We recommend that you use the most up-to-date version as things may change quickly. As of version 0.7.0 , tests have been written covering the majority of the EFP code. Get started by installing EnergyFlow and checking out the demo !","title":"Welcome to EnergyFlow"},{"location":"#references","text":"[1] P.T. Komiske, E.M. Metodiev, and J. Thaler, Energy Flow Polynomials: A complete linear basis for jet substructure , JHEP 04 (2018) 013 [ 1712.07124 ].","title":"References"},{"location":"faq/","text":"Frequently Asked EnergyFlow Questions How do I cite the EnergyFlow package? Why Python instead of C++? Can I contribute to the code? How do I report an issue or a bug? Where can I get graph image files? How do I cite the EnergyFlow package? Please cite the relevant Energy Flow papers if they or this package helps your research. Here are the BibTeX entries to use: @article{Komiske:2017aww, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Energy Flow Polynomials: A complete linear basis for jet substructure}\", journal = \"JHEP\", volume = \"04\", year = \"2018\", pages = \"013\", doi = \"10.1007/JHEP04(2018)013\", eprint = \"1712.07124\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP-4965\" } Why Python instead of C++? Computing the energy flow polynomials requires a function such as NumPy's einsum that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use. NumPy is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the energy flow polynomials. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and features such as SSE instructions. Can I contribute to the code? All of our code is open source and hosted on GitHub . We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository. How do I report an issue? Please let us know of any issues you encounter as soon as possible by creating an Issue on the EnergyFlow GitHub repository. Where can I get graph image files? Image files for all connected multigraphs with up to 7 edges in the energy flow polynomial style are available as pdf files here . You are free to use them with the proper attribution.","title":"FAQ"},{"location":"faq/#frequently-asked-energyflow-questions","text":"How do I cite the EnergyFlow package? Why Python instead of C++? Can I contribute to the code? How do I report an issue or a bug? Where can I get graph image files?","title":"Frequently Asked EnergyFlow Questions"},{"location":"faq/#how-do-i-cite-the-energyflow-package","text":"Please cite the relevant Energy Flow papers if they or this package helps your research. Here are the BibTeX entries to use: @article{Komiske:2017aww, author = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\", title = \"{Energy Flow Polynomials: A complete linear basis for jet substructure}\", journal = \"JHEP\", volume = \"04\", year = \"2018\", pages = \"013\", doi = \"10.1007/JHEP04(2018)013\", eprint = \"1712.07124\", archivePrefix = \"arXiv\", primaryClass = \"hep-ph\", reportNumber = \"MIT-CTP-4965\" }","title":"How do I cite the EnergyFlow package?"},{"location":"faq/#why-python-instead-of-c","text":"Computing the energy flow polynomials requires a function such as NumPy's einsum that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use. NumPy is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the energy flow polynomials. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and features such as SSE instructions.","title":"Why Python instead of C++?"},{"location":"faq/#can-i-contribute-to-the-code","text":"All of our code is open source and hosted on GitHub . We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository.","title":"Can I contribute to the code?"},{"location":"faq/#how-do-i-report-an-issue","text":"Please let us know of any issues you encounter as soon as possible by creating an Issue on the EnergyFlow GitHub repository.","title":"How do I report an issue?"},{"location":"faq/#where-can-i-get-graph-image-files","text":"Image files for all connected multigraphs with up to 7 edges in the energy flow polynomial style are available as pdf files here . You are free to use them with the proper attribution.","title":"Where can I get graph image files?"},{"location":"installation/","text":"The EnergyFlow package is written in pure Python and depends only on NumPy, the fundamental package for scientific computing with Python, and six, which is a lightweight module to patch some inconvenient differences between Python 2 and Python 3. The EnergyFlow package is designed to work with Python 2.7, 3.5, 3.6, and 3.7. These can be installed from here . The latest stable version of Python 3 is highly recommended. Install with pip (recommended) To install from PyPI using pip , make sure you have one of the supported versions of Python installed and that pip is available in the system path. Simply execute pip install energyflow and EnergyFlow will be installed in your default location for Python packages. Bleeding edge install EnergyFlow is hosted on GitHub and can be installed by cloning the repository and running python setup.py install . iGraph EnergyFlow relies on iGraph for generation of multigraphs. This is not required if using the provided graphs suits your needs. If you wish to generate your own graphs, make sure that iGraph is importable. NumPy Since EnergyFlow relies on numpy.einsum to do most of the computational heavy lifting, newer versions of NumPy may provide changes/speedups in performance if einsum changes. NumPy 1.14.0 changed einsum to use tensordot when possible compared to 1.13.3 , which only used c_einsum . This means that computations are faster on larger tensors but may be slower on smaller tensors. EnergyFlow currently uses only c_einsum because it was found to be substantially faster for typical pp-jet applications.","title":"Installation"},{"location":"installation/#install-with-pip-recommended","text":"To install from PyPI using pip , make sure you have one of the supported versions of Python installed and that pip is available in the system path. Simply execute pip install energyflow and EnergyFlow will be installed in your default location for Python packages.","title":"Install with pip (recommended)"},{"location":"installation/#bleeding-edge-install","text":"EnergyFlow is hosted on GitHub and can be installed by cloning the repository and running python setup.py install .","title":"Bleeding edge install"},{"location":"installation/#igraph","text":"EnergyFlow relies on iGraph for generation of multigraphs. This is not required if using the provided graphs suits your needs. If you wish to generate your own graphs, make sure that iGraph is importable.","title":"iGraph"},{"location":"installation/#numpy","text":"Since EnergyFlow relies on numpy.einsum to do most of the computational heavy lifting, newer versions of NumPy may provide changes/speedups in performance if einsum changes. NumPy 1.14.0 changed einsum to use tensordot when possible compared to 1.13.3 , which only used c_einsum . This means that computations are faster on larger tensors but may be slower on smaller tensors. EnergyFlow currently uses only c_einsum because it was found to be substantially faster for typical pp-jet applications.","title":"NumPy"},{"location":"tutorial/","text":"Jupyter Notebook Demo For an introduction to EnergyFlow, you can view or download a demo notebook here .","title":"Tutorial"},{"location":"tutorial/#jupyter-notebook-demo","text":"For an introduction to EnergyFlow, you can view or download a demo notebook here .","title":"Jupyter Notebook Demo"},{"location":"docs/archs/","text":"Test. CNN energyflow.CNN(args, kwargs) CNN docstring. DNN energyflow.DNN(args, kwargs) DNN docstring. EFN energyflow.EFN(args, kwargs) EFN docstring. PFN energyflow.PFN(args, kwargs) PFN docstring. LinearClassifier energyflow.LinearClassifier(args, kwargs) LinearClassifier docstring.","title":"Architectures"},{"location":"docs/archs/#cnn","text":"energyflow.CNN(args, kwargs) CNN docstring.","title":"CNN"},{"location":"docs/archs/#dnn","text":"energyflow.DNN(args, kwargs) DNN docstring.","title":"DNN"},{"location":"docs/archs/#efn","text":"energyflow.EFN(args, kwargs) EFN docstring.","title":"EFN"},{"location":"docs/archs/#pfn","text":"energyflow.PFN(args, kwargs) PFN docstring.","title":"PFN"},{"location":"docs/archs/#linearclassifier","text":"energyflow.LinearClassifier(args, kwargs) LinearClassifier docstring.","title":"LinearClassifier"},{"location":"docs/datasets/","text":"QG_jets load energyflow.load(num_data=-1, filename='QG_jets.npz', cache_dir=None) load docstring. QG_nsubs load energyflow.load(num_data=-1, filename='QG_nsubs.npz', cache_dir=None) load docstring.","title":"Datasets"},{"location":"docs/datasets/#qg_jets","text":"","title":"QG_jets"},{"location":"docs/datasets/#load","text":"energyflow.load(num_data=-1, filename='QG_jets.npz', cache_dir=None) load docstring.","title":"load"},{"location":"docs/datasets/#qg_nsubs","text":"","title":"QG_nsubs"},{"location":"docs/datasets/#load_1","text":"energyflow.load(num_data=-1, filename='QG_nsubs.npz', cache_dir=None) load docstring.","title":"load"},{"location":"docs/efp/","text":"Energy Flow Polynomials (EFPs) are a set of observables, indexed by non-isomorphic multigraphs, which linearly span the space of infrared and collinear safe (IRC-safe) observables. An EFP index by a multigraph $G$ takes the following form: \\text{EFP}_G=\\sum_{i_1=1}^M\\cdots\\sum_{i_N=1}^Mz_{i_1}\\cdots z_{i_N} \\prod_{(k,\\ell)\\in G}\\theta_{i_ki_\\ell} where $z_i$ is a measure of the energy of particle $i$ and $\\theta_{ij}$ is a measure of the angular separation between particles $i$ and $j$. The specific choices for energy and angular measure depend on the collider context and are discussed at length in the Measures section. EFP energyflow.EFP(edges, measure='hadrdot', beta=1, kappa=1, normed=True, coords=None, check_input=True, ve_alg='numpy', np_optimize='greedy') A class for representing and computing a single EFP. EFPSet energyflow.EFPSet(args, kwargs) A class that holds a collection of EFPs and computes their values on events.","title":"Energy Flow Polynomials"},{"location":"docs/efp/#efp","text":"energyflow.EFP(edges, measure='hadrdot', beta=1, kappa=1, normed=True, coords=None, check_input=True, ve_alg='numpy', np_optimize='greedy') A class for representing and computing a single EFP.","title":"EFP"},{"location":"docs/efp/#efpset","text":"energyflow.EFPSet(args, kwargs) A class that holds a collection of EFPs and computes their values on events.","title":"EFPSet"},{"location":"docs/gen/","text":"Implementation of EFP Generator class. Generator energyflow.Generator Generates non-isomorphic multigraphs according to provided specifications.","title":"Generation"},{"location":"docs/gen/#generator","text":"energyflow.Generator Generates non-isomorphic multigraphs according to provided specifications.","title":"Generator"},{"location":"docs/measure/","text":"Energy and Angular Measures The appropriate notions of energy and angle depend on the collider context. Typically, one wants to work with observables that respect the appropriate Lorentz subgroup for the collision type of interest. EnergyFlow is capable of handling two broad classes of measures: $e^+e^-$ and hadronic, which are selected using the measure keyword argument (default is 'hadrdot' ). For substructure applications, it is often convenient to normalize the energies so that $\\sum_iz_i=1$. The normed keyword argument is provided to control normalization of the energies (default is True ). Each measure comes with a parameter $\\beta>0$ which controls the relative weighting between smaller and larger anglular structures. This can be set using the beta keyword argument (default is 2 ). There is also a $\\kappa$ parameter to control the relative weighting between soft and hard energies. This can be set using the kappa keyword argument (default is 1 ). Only kappa=1 yields collinear-safe observables. Beyond the measures implemented here, the user can implement their own custom measure by passing ${z_i}$ and ${\\theta_{ij}}$ in directly to the EFP classes. Hadronic Measures For hadronic collisions, observables are typically desired to be invariant under boosts along the beam direction and rotations about the beam direction. Thus, particle transverse momentum $p_T$ and rapidity-azimuth coordinates $(y,\\phi)$ are often used. There are two hadronic measures implemented in EnergyFlow: 'hadr' and 'hadrdot' (the default). These are listed explicitly below. 'hadr' : z_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=(\\Delta y_{ij}^2 + \\Delta\\phi_{ij}^2)^{\\beta/2}. 'hadrdot' : z_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=\\left(\\frac{2p^\\mu_ip_{j\\mu}}{p_{T,i}p_{T,j}} \\right)^{\\beta/2}. e+e- Measures For $e^+e^-$ collisions, observables are typically desired to be invariant under the full group of reotations about the interaction point. Since the center of momentum energy is known, the particle energy $E$ is typically used. For the angular measure, pairwise Lorentz contractions of the normalized particle four-momenta are used. There is one $e^+e^-$ measure implemented in the EnergyFlow framework. 'ee' : z_i = E_{i}^{\\kappa}, \\quad\\quad \\theta_{ij} = \\left(\\frac{2p_i^\\mu p_{j \\mu}}{E_i E_j}\\right)^{\\beta/2}. Measure energyflow.Measure(args, kwargs) Class for dealing with any kind of measure.","title":"Measures"},{"location":"docs/measure/#energy-and-angular-measures","text":"The appropriate notions of energy and angle depend on the collider context. Typically, one wants to work with observables that respect the appropriate Lorentz subgroup for the collision type of interest. EnergyFlow is capable of handling two broad classes of measures: $e^+e^-$ and hadronic, which are selected using the measure keyword argument (default is 'hadrdot' ). For substructure applications, it is often convenient to normalize the energies so that $\\sum_iz_i=1$. The normed keyword argument is provided to control normalization of the energies (default is True ). Each measure comes with a parameter $\\beta>0$ which controls the relative weighting between smaller and larger anglular structures. This can be set using the beta keyword argument (default is 2 ). There is also a $\\kappa$ parameter to control the relative weighting between soft and hard energies. This can be set using the kappa keyword argument (default is 1 ). Only kappa=1 yields collinear-safe observables. Beyond the measures implemented here, the user can implement their own custom measure by passing ${z_i}$ and ${\\theta_{ij}}$ in directly to the EFP classes.","title":"Energy and Angular Measures"},{"location":"docs/measure/#hadronic-measures","text":"For hadronic collisions, observables are typically desired to be invariant under boosts along the beam direction and rotations about the beam direction. Thus, particle transverse momentum $p_T$ and rapidity-azimuth coordinates $(y,\\phi)$ are often used. There are two hadronic measures implemented in EnergyFlow: 'hadr' and 'hadrdot' (the default). These are listed explicitly below. 'hadr' : z_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=(\\Delta y_{ij}^2 + \\Delta\\phi_{ij}^2)^{\\beta/2}. 'hadrdot' : z_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=\\left(\\frac{2p^\\mu_ip_{j\\mu}}{p_{T,i}p_{T,j}} \\right)^{\\beta/2}.","title":"Hadronic Measures"},{"location":"docs/measure/#ee-measures","text":"For $e^+e^-$ collisions, observables are typically desired to be invariant under the full group of reotations about the interaction point. Since the center of momentum energy is known, the particle energy $E$ is typically used. For the angular measure, pairwise Lorentz contractions of the normalized particle four-momenta are used. There is one $e^+e^-$ measure implemented in the EnergyFlow framework. 'ee' : z_i = E_{i}^{\\kappa}, \\quad\\quad \\theta_{ij} = \\left(\\frac{2p_i^\\mu p_{j \\mu}}{E_i E_j}\\right)^{\\beta/2}.","title":"e+e- Measures"},{"location":"docs/measure/#measure","text":"energyflow.Measure(args, kwargs) Class for dealing with any kind of measure.","title":"Measure"},{"location":"docs/utils/","text":"Particle Tools Tools to compute particle kinematic quantities from four-vectors, such as transverse momentum $p_T$, rapidity $y$, and azimuthal angle $\\phi$. Also includes functions for converting between Euclidean four-momenta and $(p_T,y,\\phi,[m])$. ptyphims_from_p4s energyflow.ptyphims_from_p4s(p4s, phi_ref=None, keep_shape=True) Compute the $(p_T,y,\\phi,m)$ representation of a four-vector for each Euclidean four-vector given as input. All-zero four-vectors are removed unless keep_shape is True . Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. phi_ref : float A reference value used so that all phis will be within $\\pm\\pi$ of thie value. keep_shape : bool Flag to determine if all-zero four-vectors will be retained. This is useful for keeping the shape of an array. Returns numpy.ndarray An array of size (M, 4) consisting of the transverse momentum, rapidity, azimuthal angle, and mass of each particle. If a single particle was given as input, a one-dimensional array is returned. pts_from_p4s energyflow.pts_from_p4s(p4s) Calculate the transverse momenta of a collection of four-vectors Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the transverse momentum of each particle. If a single particle was given as input, a single float is returned. ys_from_p4s energyflow.ys_from_p4s(p4s) Calculate the rapidities of a collection of four-vectors Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the rapidity of each particle. If a single particle was given as input, a single float is returned. phis_from_p4s energyflow.phis_from_p4s(p4s, phi_ref=None) Calculate the azimuthal angles of a collection of four-vectors. If phi_ref is not None , then phi_fix is called using this value. Otherwise, the angles are chosen to be in the inverval $[0,2\\pi]$. Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. phi_ref : float See Returns numpy.ndarray or list An M -length array consisting of the azimuthal angle of each particle. If a single particle was given as input, a single float is returned. ms_from_p4s energyflow.ms_from_p4s(p4s) Calculate the masses of a collection of four-vectors. Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the mass of each particle. If a single particle was given as input, a single float is returned. p4s_from_ptyphims energyflow.p4s_from_ptyphims(ptyphims) Calculate Euclidean four-vectors from transverse momentum, rapidity, azimuthal angle, and (optionally) mass for each input. Arguments ptyphims : numpy.ndarray or list An array with shape (M, 4) of [pT, y, phi, m] for each particle. An array with shape (M, 3) is also accepted where the masses are taken to be zero. A single particle is also accepted. Returns numpy.ndarray An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. If a single particle was given as input, a single four-vector will be returned. p4s_from_ptyphis energyflow.p4s_from_ptyphis(ptyphis) Calculate Euclidean four-vectors from transverse momentum, rapidity, and azimuthal angle. Particles are taken to be massless. Arguments ptyphims : numpy.ndarray or list An array with shape (M, 3) of [pT, y, phi] for each particle. A single particle is also accepted. Returns numpy.ndarray An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. If a single particle was given as input, a single four-vector will be returned. phi_fix energyflow.phi_fix(phis, phi_ref, copy=False) A function to ensure that all phi values are within $\\pi$ of phi_ref . It is assumed that all starting phi values are within $2\\pi$ of phi_ref . Arguments phis : numpy.ndarray or list One-dimensional array of phi values. phi_ref : float A reference value used so that all phis will be within $\\pm\\pi$ of this value. copy : bool Determines if phis are copied or not. If False then phis may be modified in place. Returns numpy.ndarray An array of the fixed phi values. flat_metric energyflow.flat_metric(dim) The Minkowski metric in dim spacetime dimensions in the mostly-minus convention. Arguments dim : int The number of spacetime dimensions (thought to be four in our universe). Returns numpy.ndarray A dim -length, one-dimensional (not matrix) array equal to [+1, -1, ..., -1] Data Tools Functions for dealing with datasets. URL handling and hashing functions copied from Keras GitHub repo. The required license and copyright notice are provided in LICENSE which is distributed with this software package. get_examples energyflow.get_examples(which='all', path='~/.energyflow') Pulls examples from GitHub. data_split energyflow.data_split(args, kwargs) A function to split an arbitrary number of arrays into train, validation, and test sets. If val_frac = 0, then we don't split any events into the validation set. If exactly two arguments are given (an \"X\" and \"Y\") then we return (X_train, [X_val], X_test, Y_train, [Y_val], Y_test), otherwise i lists corresponding to the different args are returned with each list being [train, [val], test]. Note that all arguments must have the same number of samples otherwise an exception will be raised. to_categorical energyflow.to_categorical(vector, num_classes=None) One-hot encodes class labels. pixelate energyflow.pixelate(jet, npix=33, img_width=0.8, nb_chan=1, charged_counts_only=False, norm=True) A function for creating a jet image from a list of particles. jet: an array containing the list of particles in a jet with each row representing a particle and the columns being (rapidity, phi, pT, pdgid), the latter not being necessary for a grayscale image. npix: number of pixels along one dimension of the image. img_width: the image will be size img_width x img_width nb_chan: 1 - returns a grayscale image of total pt 2 - returns a two-channel image with total pt and total counts norm: whether to normalize the pT channels to 1 according to the L1 norm standardize energyflow.standardize(args, kwargs) Normalizes each argument by the standard deviation of the pixels in arg[0]. The expected use case would be standardize(X_train, X_val, X_test). channels: which channels to zero_center. The default will lead to all channels being affected. copy: if True, the arguments are unaffected. if False, the arguments themselves may be modified reg: used to prevent divide by zero zero_center energyflow.zero_center(args, kwargs) Subtracts the mean of arg[0,channels] from the other arguments. Assumes that the arguments are numpy arrays. The expected use case would be zero_center(X_train, X_val, X_test). channels: list of which channels to zero_center. The default will lead to all channels being affected. copy: if True, the arguments are unaffected. if False, the arguments themselves may be modified remap_pids energyflow.remap_pids(events, pid_i=3) Remaps PDG id numbers to small floats. Random Event Generation Functions to generate random sets of four-vectors. Includes an implementation of the RAMBO algorithm for sampling uniform M-body massless phase space. Also includes other functions for various random, non-center of momentum, and non-uniform sampling. gen_random_events energyflow.gen_random_events(nevents, nparticles, dim=4, mass=0) Generate random events with a given number of particles of a given mass in a given spacetime dimension. The energy-momentum vectors have spatial components drawn randomly from [-1,+1]. These events are not guaranteed to uniformly sample phase space. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. dim : int Number of spacetime dimensions. mass : float Mass of the particles to generate. Returns numpy.ndarray An ( nevents , nparticles , dim ) array of events, each with nparticles particles with mass given by mass . gen_random_events_massless_com energyflow.gen_random_events_massless_com(nevents, nparticles, dim=4) Generate random events with a given number of massless particles in a given spacetime dimension. The total energy and momentum are made to sum to zero by making about half of the particles incoming. These events are not guaranteed to uniformly sample phase space. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. dim : int Number of spacetime dimensions. Returns numpy.ndarray An ( nevents , nparticles , dim ) array of events, each with nparticles massless particles whose total energy and momentum are all zero. gen_massless_phase_space energyflow.gen_massless_phase_space(nevents, nparticles, energy=1) Implementation of the RAMBO algorithm for uniformly sampling massless M-body phase space for any center of mass energies. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. energy : float Total center of mass energy of each event. Returns numpy.ndarray An ( nevents , nparticles , 4) array of events, each with nparticles massless particles and center of mass energy equal to energy .","title":"Utils"},{"location":"docs/utils/#particle-tools","text":"Tools to compute particle kinematic quantities from four-vectors, such as transverse momentum $p_T$, rapidity $y$, and azimuthal angle $\\phi$. Also includes functions for converting between Euclidean four-momenta and $(p_T,y,\\phi,[m])$.","title":"Particle Tools"},{"location":"docs/utils/#ptyphims_from_p4s","text":"energyflow.ptyphims_from_p4s(p4s, phi_ref=None, keep_shape=True) Compute the $(p_T,y,\\phi,m)$ representation of a four-vector for each Euclidean four-vector given as input. All-zero four-vectors are removed unless keep_shape is True . Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. phi_ref : float A reference value used so that all phis will be within $\\pm\\pi$ of thie value. keep_shape : bool Flag to determine if all-zero four-vectors will be retained. This is useful for keeping the shape of an array. Returns numpy.ndarray An array of size (M, 4) consisting of the transverse momentum, rapidity, azimuthal angle, and mass of each particle. If a single particle was given as input, a one-dimensional array is returned.","title":"ptyphims_from_p4s"},{"location":"docs/utils/#pts_from_p4s","text":"energyflow.pts_from_p4s(p4s) Calculate the transverse momenta of a collection of four-vectors Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the transverse momentum of each particle. If a single particle was given as input, a single float is returned.","title":"pts_from_p4s"},{"location":"docs/utils/#ys_from_p4s","text":"energyflow.ys_from_p4s(p4s) Calculate the rapidities of a collection of four-vectors Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the rapidity of each particle. If a single particle was given as input, a single float is returned.","title":"ys_from_p4s"},{"location":"docs/utils/#phis_from_p4s","text":"energyflow.phis_from_p4s(p4s, phi_ref=None) Calculate the azimuthal angles of a collection of four-vectors. If phi_ref is not None , then phi_fix is called using this value. Otherwise, the angles are chosen to be in the inverval $[0,2\\pi]$. Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. phi_ref : float See Returns numpy.ndarray or list An M -length array consisting of the azimuthal angle of each particle. If a single particle was given as input, a single float is returned.","title":"phis_from_p4s"},{"location":"docs/utils/#ms_from_p4s","text":"energyflow.ms_from_p4s(p4s) Calculate the masses of a collection of four-vectors. Arguments p4s : numpy.ndarray or list An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. A single particle as a one-dimensional array or list is also accepted. Returns numpy.ndarray An M -length array consisting of the mass of each particle. If a single particle was given as input, a single float is returned.","title":"ms_from_p4s"},{"location":"docs/utils/#p4s_from_ptyphims","text":"energyflow.p4s_from_ptyphims(ptyphims) Calculate Euclidean four-vectors from transverse momentum, rapidity, azimuthal angle, and (optionally) mass for each input. Arguments ptyphims : numpy.ndarray or list An array with shape (M, 4) of [pT, y, phi, m] for each particle. An array with shape (M, 3) is also accepted where the masses are taken to be zero. A single particle is also accepted. Returns numpy.ndarray An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. If a single particle was given as input, a single four-vector will be returned.","title":"p4s_from_ptyphims"},{"location":"docs/utils/#p4s_from_ptyphis","text":"energyflow.p4s_from_ptyphis(ptyphis) Calculate Euclidean four-vectors from transverse momentum, rapidity, and azimuthal angle. Particles are taken to be massless. Arguments ptyphims : numpy.ndarray or list An array with shape (M, 3) of [pT, y, phi] for each particle. A single particle is also accepted. Returns numpy.ndarray An event as an (M, 4) array of four-vectors [E, px, py, pz] for each particle. If a single particle was given as input, a single four-vector will be returned.","title":"p4s_from_ptyphis"},{"location":"docs/utils/#phi_fix","text":"energyflow.phi_fix(phis, phi_ref, copy=False) A function to ensure that all phi values are within $\\pi$ of phi_ref . It is assumed that all starting phi values are within $2\\pi$ of phi_ref . Arguments phis : numpy.ndarray or list One-dimensional array of phi values. phi_ref : float A reference value used so that all phis will be within $\\pm\\pi$ of this value. copy : bool Determines if phis are copied or not. If False then phis may be modified in place. Returns numpy.ndarray An array of the fixed phi values.","title":"phi_fix"},{"location":"docs/utils/#flat_metric","text":"energyflow.flat_metric(dim) The Minkowski metric in dim spacetime dimensions in the mostly-minus convention. Arguments dim : int The number of spacetime dimensions (thought to be four in our universe). Returns numpy.ndarray A dim -length, one-dimensional (not matrix) array equal to [+1, -1, ..., -1]","title":"flat_metric"},{"location":"docs/utils/#data-tools","text":"Functions for dealing with datasets. URL handling and hashing functions copied from Keras GitHub repo. The required license and copyright notice are provided in LICENSE which is distributed with this software package.","title":"Data Tools"},{"location":"docs/utils/#get_examples","text":"energyflow.get_examples(which='all', path='~/.energyflow') Pulls examples from GitHub.","title":"get_examples"},{"location":"docs/utils/#data_split","text":"energyflow.data_split(args, kwargs) A function to split an arbitrary number of arrays into train, validation, and test sets. If val_frac = 0, then we don't split any events into the validation set. If exactly two arguments are given (an \"X\" and \"Y\") then we return (X_train, [X_val], X_test, Y_train, [Y_val], Y_test), otherwise i lists corresponding to the different args are returned with each list being [train, [val], test]. Note that all arguments must have the same number of samples otherwise an exception will be raised.","title":"data_split"},{"location":"docs/utils/#to_categorical","text":"energyflow.to_categorical(vector, num_classes=None) One-hot encodes class labels.","title":"to_categorical"},{"location":"docs/utils/#pixelate","text":"energyflow.pixelate(jet, npix=33, img_width=0.8, nb_chan=1, charged_counts_only=False, norm=True) A function for creating a jet image from a list of particles. jet: an array containing the list of particles in a jet with each row representing a particle and the columns being (rapidity, phi, pT, pdgid), the latter not being necessary for a grayscale image. npix: number of pixels along one dimension of the image. img_width: the image will be size img_width x img_width nb_chan: 1 - returns a grayscale image of total pt 2 - returns a two-channel image with total pt and total counts norm: whether to normalize the pT channels to 1 according to the L1 norm","title":"pixelate"},{"location":"docs/utils/#standardize","text":"energyflow.standardize(args, kwargs) Normalizes each argument by the standard deviation of the pixels in arg[0]. The expected use case would be standardize(X_train, X_val, X_test). channels: which channels to zero_center. The default will lead to all channels being affected. copy: if True, the arguments are unaffected. if False, the arguments themselves may be modified reg: used to prevent divide by zero","title":"standardize"},{"location":"docs/utils/#zero_center","text":"energyflow.zero_center(args, kwargs) Subtracts the mean of arg[0,channels] from the other arguments. Assumes that the arguments are numpy arrays. The expected use case would be zero_center(X_train, X_val, X_test). channels: list of which channels to zero_center. The default will lead to all channels being affected. copy: if True, the arguments are unaffected. if False, the arguments themselves may be modified","title":"zero_center"},{"location":"docs/utils/#remap_pids","text":"energyflow.remap_pids(events, pid_i=3) Remaps PDG id numbers to small floats.","title":"remap_pids"},{"location":"docs/utils/#random-event-generation","text":"Functions to generate random sets of four-vectors. Includes an implementation of the RAMBO algorithm for sampling uniform M-body massless phase space. Also includes other functions for various random, non-center of momentum, and non-uniform sampling.","title":"Random Event Generation"},{"location":"docs/utils/#gen_random_events","text":"energyflow.gen_random_events(nevents, nparticles, dim=4, mass=0) Generate random events with a given number of particles of a given mass in a given spacetime dimension. The energy-momentum vectors have spatial components drawn randomly from [-1,+1]. These events are not guaranteed to uniformly sample phase space. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. dim : int Number of spacetime dimensions. mass : float Mass of the particles to generate. Returns numpy.ndarray An ( nevents , nparticles , dim ) array of events, each with nparticles particles with mass given by mass .","title":"gen_random_events"},{"location":"docs/utils/#gen_random_events_massless_com","text":"energyflow.gen_random_events_massless_com(nevents, nparticles, dim=4) Generate random events with a given number of massless particles in a given spacetime dimension. The total energy and momentum are made to sum to zero by making about half of the particles incoming. These events are not guaranteed to uniformly sample phase space. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. dim : int Number of spacetime dimensions. Returns numpy.ndarray An ( nevents , nparticles , dim ) array of events, each with nparticles massless particles whose total energy and momentum are all zero.","title":"gen_random_events_massless_com"},{"location":"docs/utils/#gen_massless_phase_space","text":"energyflow.gen_massless_phase_space(nevents, nparticles, energy=1) Implementation of the RAMBO algorithm for uniformly sampling massless M-body phase space for any center of mass energies. Arguments nevents : int Number of events to generate. nparticles : int Number of particles in each event. energy : float Total center of mass energy of each event. Returns numpy.ndarray An ( nevents , nparticles , 4) array of events, each with nparticles massless particles and center of mass energy equal to energy .","title":"gen_massless_phase_space"}]}