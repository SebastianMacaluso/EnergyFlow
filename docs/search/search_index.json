{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to EnergyFlow\n\n\nEnergyFlow is a Python package for computing Energy Flow Polynomials (EFPs), a collection of jet substructure observables which form a complete, linear basis of IRC-safe observables. The source code can be found on \nGitHub\n.\n\n\nNote\n: We are currently in beta. Fully tested code and site coming soon!\n\n\nReferences\n\n\n[1] P.T. Komiske, E.M. Metodiev, J. Thaler, \"Energy Flow Polynomials: A complete linear basis for jet substructure.\" \nTo appear soon.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-energyflow",
            "text": "EnergyFlow is a Python package for computing Energy Flow Polynomials (EFPs), a collection of jet substructure observables which form a complete, linear basis of IRC-safe observables. The source code can be found on  GitHub .  Note : We are currently in beta. Fully tested code and site coming soon!",
            "title": "Welcome to EnergyFlow"
        },
        {
            "location": "/#references",
            "text": "[1] P.T. Komiske, E.M. Metodiev, J. Thaler, \"Energy Flow Polynomials: A complete linear basis for jet substructure.\"  To appear soon.",
            "title": "References"
        },
        {
            "location": "/intro/efpintro/",
            "text": "The Energy Flow Basis\n\n\nEnergy flow polynomials (EFPs) are a set of observables, indexed by non-isomorphic multigraphs, which linearly span the space of infrared and collinear safe (IRC-safe) observables.\n\n\nAn EFP index by a multigraph $G$ takes the following form:\n\n \\text{EFP}_G =  \\sum_{i_1=1}^M \\cdots \\sum_{i_N = 1}^M z_{i_1}\\cdots z_{i_N} \\prod_{(k,\\ell)\\in G} \\theta_{i_k i_\\ell}\n\nwhere $z_i$ is a measure of the energy of particle $i$ and $\\theta_{ij}$ is a measure of the angular separation between particles $i$ and $j$. The specific choices for energy and angular measure depend on the collider context and are discussed at length in the \nMeasures\n section.",
            "title": "Energy Flow Polynomials"
        },
        {
            "location": "/intro/efpintro/#the-energy-flow-basis",
            "text": "Energy flow polynomials (EFPs) are a set of observables, indexed by non-isomorphic multigraphs, which linearly span the space of infrared and collinear safe (IRC-safe) observables.  An EFP index by a multigraph $G$ takes the following form:  \\text{EFP}_G =  \\sum_{i_1=1}^M \\cdots \\sum_{i_N = 1}^M z_{i_1}\\cdots z_{i_N} \\prod_{(k,\\ell)\\in G} \\theta_{i_k i_\\ell} \nwhere $z_i$ is a measure of the energy of particle $i$ and $\\theta_{ij}$ is a measure of the angular separation between particles $i$ and $j$. The specific choices for energy and angular measure depend on the collider context and are discussed at length in the  Measures  section.",
            "title": "The Energy Flow Basis"
        },
        {
            "location": "/intro/measures/",
            "text": "Energy and Angular Measures\n\n\nThe appropriate notions of energy and angle depend on the collider context. Typically, one wants to work with observables that respect the appropriate Lorentz subgroup for the collision type of interest. EnergyFlow is capable of handling two broad classes of measures: $e^+e^-$ and hadronic, which are selected using the \nmeasure\n keyword argument (the defaul is \n'hadr'\n, described below).\n\n\nFor substructure applications, it is often convenient to normalize the energies so that $\\sum_iz_i=1$. The \nnormed\n keyword argument is provided to control normalization of the energies (the default is \nTrue\n).\n\n\nEach measure comes with a parameter $\\beta>0$ which controls the relative weighting between small and larger angles. This can be set using the \nbeta\n keyword argument (the default is \n1\n.\n\n\nBeyond the measures implemented here, the user can implement their own custom measure by passing ${z_i}$ and ${\\theta_{ij}}$ in directly to the EFP classes.\n\n\nHadronic Collisions\n\n\nFor hadronic collisions, observables are typically desired to be invariant under boosts along the beam direction and rotations about the beam direction. Thus, particle transverse momentum $p_T$ and rapidity-azimuth coordinates $(y,\\phi)$ are often used.\n\n\nThere are two hadronic measures implemented in EnergyFlow: \n'hadr'\n (the default) and \n'hadr-dot'\n. These are listed explicitly below in the normalized-energy version (the unnormalized version follows by removing the denominator).\n\n\n'hadr'\n:\n\nz_i=\\frac{p_{T,i}}{\\displaystyle\\sum_{k=1}^Mp_{T,k}},\\quad\\quad \\theta_{ij}=(\\Delta y_{ij}^2 + \\Delta\\phi_{ij}^2)^{\\beta/2}.\n\n\n\n\n'hadr-dot'\n:\n\nz_i=\\frac{p_{T,i}}{\\displaystyle\\sum_{k=1}^Mp_{T,k}},\\quad\\quad \\theta_{ij}=\\left(\\frac{2p^\\mu_ip_{j\\mu}}{p_{T,i}p_{T,j}}\\right)^{\\beta/2}.\n\n\n\n\ne+e-\n Collisions\n\n\nFor $e^+e^-$ collisions, observables are typically desired to be invariant under the full group of reotations about the interaction point. Since the center of momentum energy is known, the particle energy $E$ is typically used. For the angular measure, pairwise Lorentz contractions of the normalized particle four-momenta are used.\n\n\nThere is one $e^+e^-$ measure implemented in the EnergyFlow framework.\n\n\n'ee'\n:\n\nz_i = \\frac{E_{i}}{\\displaystyle\\sum_{k=1} E_{k}},\n\\quad\\quad \\theta_{ij} = \\left(\\frac{2p_i^\\mu p_{j \\mu}}{E_i E_j}\\right)^{\\beta/2}.",
            "title": "Measures"
        },
        {
            "location": "/intro/measures/#energy-and-angular-measures",
            "text": "The appropriate notions of energy and angle depend on the collider context. Typically, one wants to work with observables that respect the appropriate Lorentz subgroup for the collision type of interest. EnergyFlow is capable of handling two broad classes of measures: $e^+e^-$ and hadronic, which are selected using the  measure  keyword argument (the defaul is  'hadr' , described below).  For substructure applications, it is often convenient to normalize the energies so that $\\sum_iz_i=1$. The  normed  keyword argument is provided to control normalization of the energies (the default is  True ).  Each measure comes with a parameter $\\beta>0$ which controls the relative weighting between small and larger angles. This can be set using the  beta  keyword argument (the default is  1 .  Beyond the measures implemented here, the user can implement their own custom measure by passing ${z_i}$ and ${\\theta_{ij}}$ in directly to the EFP classes.",
            "title": "Energy and Angular Measures"
        },
        {
            "location": "/intro/measures/#hadronic-collisions",
            "text": "For hadronic collisions, observables are typically desired to be invariant under boosts along the beam direction and rotations about the beam direction. Thus, particle transverse momentum $p_T$ and rapidity-azimuth coordinates $(y,\\phi)$ are often used.  There are two hadronic measures implemented in EnergyFlow:  'hadr'  (the default) and  'hadr-dot' . These are listed explicitly below in the normalized-energy version (the unnormalized version follows by removing the denominator).  'hadr' : z_i=\\frac{p_{T,i}}{\\displaystyle\\sum_{k=1}^Mp_{T,k}},\\quad\\quad \\theta_{ij}=(\\Delta y_{ij}^2 + \\Delta\\phi_{ij}^2)^{\\beta/2}.   'hadr-dot' : z_i=\\frac{p_{T,i}}{\\displaystyle\\sum_{k=1}^Mp_{T,k}},\\quad\\quad \\theta_{ij}=\\left(\\frac{2p^\\mu_ip_{j\\mu}}{p_{T,i}p_{T,j}}\\right)^{\\beta/2}.",
            "title": "Hadronic Collisions"
        },
        {
            "location": "/intro/measures/#ee-collisions",
            "text": "For $e^+e^-$ collisions, observables are typically desired to be invariant under the full group of reotations about the interaction point. Since the center of momentum energy is known, the particle energy $E$ is typically used. For the angular measure, pairwise Lorentz contractions of the normalized particle four-momenta are used.  There is one $e^+e^-$ measure implemented in the EnergyFlow framework.  'ee' : z_i = \\frac{E_{i}}{\\displaystyle\\sum_{k=1} E_{k}},\n\\quad\\quad \\theta_{ij} = \\left(\\frac{2p_i^\\mu p_{j \\mu}}{E_i E_j}\\right)^{\\beta/2}.",
            "title": "e+e- Collisions"
        },
        {
            "location": "/installation/",
            "text": "The EnergyFlow package is (currently) written in pure Python and depends only on NumPy, the fundamental package for scientific computing with Python, and six, which is a lightweight module to patch some inconvenient differences between Python 2 and Python3.\n\n\nThe EnergyFlow package is designed to work with Python 2.7, 3.4, 3.5, 3.6. These can be installed from \nhere\n. The latest stable version of Python 3 is highly recommended.\n\n\nInstall with \npip\n (recommended)\n\n\nTo install from PyPI using \npip\n, make sure you have one of the supported versions of Python installed and that \npip\n is available in the system path. Simply execute \npip install energyflow\n and EnergyFlow will be installed in your default location for Python packages.\n\n\nBleeding edge install\n\n\nEnergyFlow is \nhosted on GitHub\n and can be installed by cloning the repository and running \npython setup.py install\n. This is not recommended compared to installation with \npip\n because the released versions are more thoroughly tested.\n\n\niGraph\n\n\nDevelopment NumPy\n\n\nSince EnergyFlow relies on \nnumpy.einsum\n to do most of the computational heavy lifting, newer versions of NumPy may provide changes/speedups in performance if \neinsum\n changes. At the present time, the master branch of the NumPy repo contains some significant changes to \neinsum\n compared to NumPy \n1.1.13\n. Currently, we recommend using the latest stable version of NumPy, but this may change in the future.",
            "title": "Installation"
        },
        {
            "location": "/installation/#install-with-pip-recommended",
            "text": "To install from PyPI using  pip , make sure you have one of the supported versions of Python installed and that  pip  is available in the system path. Simply execute  pip install energyflow  and EnergyFlow will be installed in your default location for Python packages.",
            "title": "Install with pip (recommended)"
        },
        {
            "location": "/installation/#bleeding-edge-install",
            "text": "EnergyFlow is  hosted on GitHub  and can be installed by cloning the repository and running  python setup.py install . This is not recommended compared to installation with  pip  because the released versions are more thoroughly tested.",
            "title": "Bleeding edge install"
        },
        {
            "location": "/installation/#igraph",
            "text": "",
            "title": "iGraph"
        },
        {
            "location": "/installation/#development-numpy",
            "text": "Since EnergyFlow relies on  numpy.einsum  to do most of the computational heavy lifting, newer versions of NumPy may provide changes/speedups in performance if  einsum  changes. At the present time, the master branch of the NumPy repo contains some significant changes to  einsum  compared to NumPy  1.1.13 . Currently, we recommend using the latest stable version of NumPy, but this may change in the future.",
            "title": "Development NumPy"
        },
        {
            "location": "/tutorial/",
            "text": "Jupyter Notebook Demo\n\n\nFor an introduction to EnergyFlow, you can view or download a demo notebook \nhere\n.",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#jupyter-notebook-demo",
            "text": "For an introduction to EnergyFlow, you can view or download a demo notebook  here .",
            "title": "Jupyter Notebook Demo"
        },
        {
            "location": "/faq/",
            "text": "Frequently Asked EnergyFlow Questions\n\n\n\n\nHow do I cite the EnergyFlow package?\n\n\nWhy Python instead of C++?\n\n\nCan I contribute to the code?\n\n\nHow do I report an issue or a bug?\n\n\nWhere can I get graph image files?\n\n\n\n\n\n\nHow do I cite the EnergyFlow package?\n\n\nPlease cite the relevant Energy Flow papers if they or this package helps your research. Here are the BibTeX entries to use:\n\n\n@article{Komiske:temp,\n      author         = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\",\n      title          = \"{Energy Flow Polynomials: A complete linear basis for jet substructure}\",\n      archivePrefix  = \"arXiv\",\n      primaryClass   = \"hep-ph\",\n      reportNumber   = \"MIT-CTP-4965\",\n }\n\n\n\n\nWhy Python instead of C++?\n\n\nComputing the energy flow polynomials requires a function such as NumPy's \neinsum\n that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use.\n\n\nNumPy\n is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the energy flow polynomials. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and features such as SSE instructions.\n\n\nCan I contribute to the code?\n\n\nAll of our code is open source and hosted on \nGitHub\n. We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository.\n\n\nHow do I report an issue?\n\n\nPlease let us know of any issues you encounter as soon as possible by creating an \nIssue\n on the EnergyFlow GitHub repository.\n\n\nWhere can I get graph image files?\n\n\nImage files for all connected multigraphs with up to 7 edges in the energy flow polynomial style are available as pdf files \nhere\n. You are free to use them with the proper attribution.",
            "title": "FAQ"
        },
        {
            "location": "/faq/#frequently-asked-energyflow-questions",
            "text": "How do I cite the EnergyFlow package?  Why Python instead of C++?  Can I contribute to the code?  How do I report an issue or a bug?  Where can I get graph image files?",
            "title": "Frequently Asked EnergyFlow Questions"
        },
        {
            "location": "/faq/#how-do-i-cite-the-energyflow-package",
            "text": "Please cite the relevant Energy Flow papers if they or this package helps your research. Here are the BibTeX entries to use:  @article{Komiske:temp,\n      author         = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\",\n      title          = \"{Energy Flow Polynomials: A complete linear basis for jet substructure}\",\n      archivePrefix  = \"arXiv\",\n      primaryClass   = \"hep-ph\",\n      reportNumber   = \"MIT-CTP-4965\",\n }",
            "title": "How do I cite the EnergyFlow package?"
        },
        {
            "location": "/faq/#why-python-instead-of-c",
            "text": "Computing the energy flow polynomials requires a function such as NumPy's  einsum  that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use.  NumPy  is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the energy flow polynomials. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and features such as SSE instructions.",
            "title": "Why Python instead of C++?"
        },
        {
            "location": "/faq/#can-i-contribute-to-the-code",
            "text": "All of our code is open source and hosted on  GitHub . We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository.",
            "title": "Can I contribute to the code?"
        },
        {
            "location": "/faq/#how-do-i-report-an-issue",
            "text": "Please let us know of any issues you encounter as soon as possible by creating an  Issue  on the EnergyFlow GitHub repository.",
            "title": "How do I report an issue?"
        },
        {
            "location": "/faq/#where-can-i-get-graph-image-files",
            "text": "Image files for all connected multigraphs with up to 7 edges in the energy flow polynomial style are available as pdf files  here . You are free to use them with the proper attribution.",
            "title": "Where can I get graph image files?"
        },
        {
            "location": "/docs/multigraphs/",
            "text": "A subpackage for handling multigraph generation.\nNote that unless igraph is importable, the functionality of this module will not be available.\nIn this case, EnergyFlow is still usable with the provided default file of precomputed multigraphs.\n\n\n\n\nGenerator\n\n\nA class that facilitates multigraph generation.\n\n\nMultiraphs are generated by first finding all simple graphs up to some nmax\nnumber of vertices, emax number of edges, and cmax VE complexity (which \ndepends on the particular VE implementation chosen). Next, weights are added\nto each of these simple graphs using integer partitions up to dome dmax number \nof multigraph edges. Disconnected graphs are determined using the connected \ngraphs by using integer partitions to determine all unique multiplications of\nthe connected graphs up to nmax and dmax.\n\n\nSince computation will ultimately be done with numpy.einsum, einstrings and\neinpaths are also computed for each simple graph\n\n\nMultigraphs and associated properties can be easily saved in a .npz file.\n\n\nGenerator(dmax, nmax=None, emax=None, cmax=None, verbose=False, ve_alg=numpy, np_optimize=greedy)\n\n\n\n\nInitializes a Generator object for generating multigraphs.\n\n\nParameters\n\n\n\n\n\n\ndmax\n : \nint\n\n    test\n\nReturns\n\n\n\n\n\n\noutput\n : \nGenerator\n\n    The Generator object.\n\n\n\n\n\n\nsave\n\n\nsave(filename)",
            "title": "Multigraphs"
        },
        {
            "location": "/docs/multigraphs/#generator",
            "text": "A class that facilitates multigraph generation.  Multiraphs are generated by first finding all simple graphs up to some nmax\nnumber of vertices, emax number of edges, and cmax VE complexity (which \ndepends on the particular VE implementation chosen). Next, weights are added\nto each of these simple graphs using integer partitions up to dome dmax number \nof multigraph edges. Disconnected graphs are determined using the connected \ngraphs by using integer partitions to determine all unique multiplications of\nthe connected graphs up to nmax and dmax.  Since computation will ultimately be done with numpy.einsum, einstrings and\neinpaths are also computed for each simple graph  Multigraphs and associated properties can be easily saved in a .npz file.  Generator(dmax, nmax=None, emax=None, cmax=None, verbose=False, ve_alg=numpy, np_optimize=greedy)  Initializes a Generator object for generating multigraphs.  Parameters    dmax  :  int \n    test Returns    output  :  Generator \n    The Generator object.",
            "title": "Generator"
        },
        {
            "location": "/docs/multigraphs/#save",
            "text": "save(filename)",
            "title": "save"
        },
        {
            "location": "/docs/polynomials/",
            "text": "These are the classes that actually compute EFPs.\nIf you plan on studying single graphs, \nEFP\n would typically be used.\nFor studying EFPs in large collections, use \nEFPSet\n for greater efficiency and simplicity.\n\n\n\n\nEFP\n\n\nA class for a storing and computing a single EFP.\n\n\nEFP(edges, measure=hadr, beta=1, normed=True, check_type=True, ve_alg=numpy, np_optimize=greedy)\n\n\n\n\nArguments\n\n\n\n\nedges\n : \nlist\n\n    Edges of the EFP graph specified by tuple-pairs of vertices.\n\n\nmeasure\n : \nstring, optional\n\n    See \nMeasures\n for options.\n\n\nbeta\n : \nfloat, optional\n\n    A value greater than zero.\n\n\nnormed\n : \nbool, optional\n\n    Controls energy normalization.\n\n\ncheck_type\n : \nbool, optional\n\n    Whether to check the type of the input or use the first input type.\n\n\nve_alg\n : \nstring, optional\n\n    Controls which variable elimination algorithm is used, either \nnumpy\n or \nef\n. Leave as \nnumpy\n unless you know what you're doing.\n\n\nnp_optimize\n : \nstring, optional\n\n    When \nve_alg='numpy'\n this is the \noptimize\n keyword of \nnumpy.einsum_path\n\n\n\n\nbatch_compute\n\n\nbatch_compute(events=None, zs=None, thetas=None, n_jobs=-1)\n\n\n\n\ncompute\n\n\ncompute(event=None, zs=None, thetas=None)\n\n\n\n\n\n\nEFPSet\n\n\nA class that holds a collection of EFPs and computes their values on events.\n\n\nEFPSet(*args, filename=None, measure='hadr', beta=1, normed=True, check_type=False, verbose=False)\n\n\n\n\nEFPSet can be initialized in one of three ways (in order of precedence):\n\n\n\n\nGenerator\n - Pass in a custom \nGenerator\n object as the first positional argument.\n\n\nCustom File\n - Pass in the name of a \n.npz\n file saved with a custom \nGenerator\n.\n\n\nDefault\n - Use the EFPs that come installed with the \nEnergFlow\n package.\n\n\n\n\nTo control which EFPs are included, \nEFPSet\n accepts an arbitrary number of specifications\n(see \nsel\n) and only EFPs meeting each specification are included in the set.\n\n\nArguments\n\n\n\n\n*args\n : \narbitrary positional arguments\n\n\nIf the first positional argument is a \nGenerator\n instance, it is used for\ninitialization. The remaining positional arguments must be valid arguments to \nsel\n.\n\n\n\n\n\n\nfilename\n : \nstring\n\n\nPath to a \n.npz\n file which has been saved by a valid \nenergyflow.Generator\n.\n\n\n\n\n\n\nmeasure\n : \nstring\n\n\nOne of \n'hadr'\n, \n'hadr-dot'\n, \n'ee'\n.\nSee \nMeasures\n additional info.\n\n\n\n\n\n\nbeta\n : \nfloat\n\n\nThe parameter $\\beta$ appearing in the measure. Must be greater than zero.\n\n\n\n\n\n\nnormed\n : \nbool\n\n\nControls normalization of the energies in the measure.\n\n\n\n\n\n\ncheck_type\n : \nbool\n\n\nWhether to check the type of the input each time or use the first input type.\n\n\n\n\n\n\nverbose\n : \nbool\n\n\n\n\nbatch_compute\n\n\nbatch_compute(events=None, zs=None, thetas=None, n_jobs=-1, calc_all=True)\n\n\n\n\ncalc_disc\n\n\ncalc_disc(X, concat=False)\n\n\n\n\ncompute\n\n\ncompute(event=None, zs=None, thetas=None)\n\n\n\n\ncount\n\n\ncount(*args, specs=None)\n\n\n\n\ngraphs\n\n\ngraphs(args)\n\n\n\n\nsel\n\n\nsel(*args, specs=None)\n\n\n\n\nsimple_graphs\n\n\nsimple_graphs(args)",
            "title": "Polynomials"
        },
        {
            "location": "/docs/polynomials/#efp",
            "text": "A class for a storing and computing a single EFP.  EFP(edges, measure=hadr, beta=1, normed=True, check_type=True, ve_alg=numpy, np_optimize=greedy)  Arguments   edges  :  list \n    Edges of the EFP graph specified by tuple-pairs of vertices.  measure  :  string, optional \n    See  Measures  for options.  beta  :  float, optional \n    A value greater than zero.  normed  :  bool, optional \n    Controls energy normalization.  check_type  :  bool, optional \n    Whether to check the type of the input or use the first input type.  ve_alg  :  string, optional \n    Controls which variable elimination algorithm is used, either  numpy  or  ef . Leave as  numpy  unless you know what you're doing.  np_optimize  :  string, optional \n    When  ve_alg='numpy'  this is the  optimize  keyword of  numpy.einsum_path",
            "title": "EFP"
        },
        {
            "location": "/docs/polynomials/#batch_compute",
            "text": "batch_compute(events=None, zs=None, thetas=None, n_jobs=-1)",
            "title": "batch_compute"
        },
        {
            "location": "/docs/polynomials/#compute",
            "text": "compute(event=None, zs=None, thetas=None)",
            "title": "compute"
        },
        {
            "location": "/docs/polynomials/#efpset",
            "text": "A class that holds a collection of EFPs and computes their values on events.  EFPSet(*args, filename=None, measure='hadr', beta=1, normed=True, check_type=False, verbose=False)  EFPSet can be initialized in one of three ways (in order of precedence):   Generator  - Pass in a custom  Generator  object as the first positional argument.  Custom File  - Pass in the name of a  .npz  file saved with a custom  Generator .  Default  - Use the EFPs that come installed with the  EnergFlow  package.   To control which EFPs are included,  EFPSet  accepts an arbitrary number of specifications\n(see  sel ) and only EFPs meeting each specification are included in the set.  Arguments   *args  :  arbitrary positional arguments  If the first positional argument is a  Generator  instance, it is used for\ninitialization. The remaining positional arguments must be valid arguments to  sel .    filename  :  string  Path to a  .npz  file which has been saved by a valid  energyflow.Generator .    measure  :  string  One of  'hadr' ,  'hadr-dot' ,  'ee' .\nSee  Measures  additional info.    beta  :  float  The parameter $\\beta$ appearing in the measure. Must be greater than zero.    normed  :  bool  Controls normalization of the energies in the measure.    check_type  :  bool  Whether to check the type of the input each time or use the first input type.    verbose  :  bool",
            "title": "EFPSet"
        },
        {
            "location": "/docs/polynomials/#batch_compute_1",
            "text": "batch_compute(events=None, zs=None, thetas=None, n_jobs=-1, calc_all=True)",
            "title": "batch_compute"
        },
        {
            "location": "/docs/polynomials/#calc_disc",
            "text": "calc_disc(X, concat=False)",
            "title": "calc_disc"
        },
        {
            "location": "/docs/polynomials/#compute_1",
            "text": "compute(event=None, zs=None, thetas=None)",
            "title": "compute"
        },
        {
            "location": "/docs/polynomials/#count",
            "text": "count(*args, specs=None)",
            "title": "count"
        },
        {
            "location": "/docs/polynomials/#graphs",
            "text": "graphs(args)",
            "title": "graphs"
        },
        {
            "location": "/docs/polynomials/#sel",
            "text": "sel(*args, specs=None)",
            "title": "sel"
        },
        {
            "location": "/docs/polynomials/#simple_graphs",
            "text": "simple_graphs(args)",
            "title": "simple_graphs"
        }
    ]
}