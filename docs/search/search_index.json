{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to EnergyFlow\n\n\nEnergyFlow is a Python package for computing Energy Flow Polynomials (EFPs), a collection of jet substructure observables which form a complete, linear basis of IRC-safe observables. The source code can be found on \nGitHub\n.\n\n\nThe current version is \n0.9.0\n. We recommend that you use the most up-to-date version as things may change quickly. As of version \n0.7.0\n, tests have been written covering the majority of the EFP code.\n\n\nGet started by \ninstalling EnergyFlow\n and \nchecking out the demo\n!\n\n\nReferences\n\n\n[1] P.T. Komiske, E.M. Metodiev, and J. Thaler, \nEnergy Flow Polynomials: A complete linear basis for jet substructure\n, \nJHEP \n04\n (2018) 013\n [\n1712.07124\n].",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-energyflow",
            "text": "EnergyFlow is a Python package for computing Energy Flow Polynomials (EFPs), a collection of jet substructure observables which form a complete, linear basis of IRC-safe observables. The source code can be found on  GitHub .  The current version is  0.9.0 . We recommend that you use the most up-to-date version as things may change quickly. As of version  0.7.0 , tests have been written covering the majority of the EFP code.  Get started by  installing EnergyFlow  and  checking out the demo !",
            "title": "Welcome to EnergyFlow"
        },
        {
            "location": "/#references",
            "text": "[1] P.T. Komiske, E.M. Metodiev, and J. Thaler,  Energy Flow Polynomials: A complete linear basis for jet substructure ,  JHEP  04  (2018) 013  [ 1712.07124 ].",
            "title": "References"
        },
        {
            "location": "/installation/",
            "text": "The EnergyFlow package is written in pure Python and depends only on NumPy, the fundamental package for scientific computing with Python, and six, which is a lightweight module to patch some inconvenient differences between Python 2 and Python 3.\n\n\nThe EnergyFlow package is designed to work with Python 2.7, 3.5, and 3.6. These can be installed from \nhere\n. The latest stable version of Python 3 is highly recommended.\n\n\nInstall with \npip\n (recommended)\n\n\nTo install from PyPI using \npip\n, make sure you have one of the supported versions of Python installed and that \npip\n is available in the system path. Simply execute \npip install energyflow\n and EnergyFlow will be installed in your default location for Python packages.\n\n\nBleeding edge install\n\n\nEnergyFlow is \nhosted on GitHub\n and can be installed by cloning the repository and running \npython setup.py install\n.\n\n\niGraph\n\n\nEnergyFlow relies on \niGraph\n for generation of multigraphs. This is not required if using the provided graphs suits your needs. If you wish to generate your own graphs, make sure that iGraph is importable.\n\n\nNumPy\n\n\nSince EnergyFlow relies on \nnumpy.einsum\n to do most of the computational heavy lifting, newer versions of NumPy may provide changes/speedups in performance if \neinsum\n changes. NumPy \n1.14.0\n changed \neinsum\n to use \ntensordot\n when possible compared to \n1.13.3\n, which only used \nc_einsum\n. This means that computations are faster on larger tensors but may be slower on smaller tensors. EnergyFlow currently uses only \nc_einsum\n because it was found to be substantially faster for typical pp-jet applications.",
            "title": "Installation"
        },
        {
            "location": "/installation/#install-with-pip-recommended",
            "text": "To install from PyPI using  pip , make sure you have one of the supported versions of Python installed and that  pip  is available in the system path. Simply execute  pip install energyflow  and EnergyFlow will be installed in your default location for Python packages.",
            "title": "Install with pip (recommended)"
        },
        {
            "location": "/installation/#bleeding-edge-install",
            "text": "EnergyFlow is  hosted on GitHub  and can be installed by cloning the repository and running  python setup.py install .",
            "title": "Bleeding edge install"
        },
        {
            "location": "/installation/#igraph",
            "text": "EnergyFlow relies on  iGraph  for generation of multigraphs. This is not required if using the provided graphs suits your needs. If you wish to generate your own graphs, make sure that iGraph is importable.",
            "title": "iGraph"
        },
        {
            "location": "/installation/#numpy",
            "text": "Since EnergyFlow relies on  numpy.einsum  to do most of the computational heavy lifting, newer versions of NumPy may provide changes/speedups in performance if  einsum  changes. NumPy  1.14.0  changed  einsum  to use  tensordot  when possible compared to  1.13.3 , which only used  c_einsum . This means that computations are faster on larger tensors but may be slower on smaller tensors. EnergyFlow currently uses only  c_einsum  because it was found to be substantially faster for typical pp-jet applications.",
            "title": "NumPy"
        },
        {
            "location": "/tutorial/",
            "text": "Jupyter Notebook Demo\n\n\nFor an introduction to EnergyFlow, you can view or download a demo notebook \nhere\n.",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/#jupyter-notebook-demo",
            "text": "For an introduction to EnergyFlow, you can view or download a demo notebook  here .",
            "title": "Jupyter Notebook Demo"
        },
        {
            "location": "/faq/",
            "text": "Frequently Asked EnergyFlow Questions\n\n\n\n\nHow do I cite the EnergyFlow package?\n\n\nWhy Python instead of C++?\n\n\nCan I contribute to the code?\n\n\nHow do I report an issue or a bug?\n\n\nWhere can I get graph image files?\n\n\n\n\n\n\nHow do I cite the EnergyFlow package?\n\n\nPlease cite the relevant Energy Flow papers if they or this package helps your research. Here are the BibTeX entries to use:\n\n\n@article{Komiske:2017aww,\n      author         = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\",\n      title          = \"{Energy Flow Polynomials: A complete linear basis for jet substructure}\",\n      journal        = \"JHEP\",\n      volume         = \"04\",\n      year           = \"2018\",\n      pages          = \"013\",\n      doi            = \"10.1007/JHEP04(2018)013\",\n      eprint         = \"1712.07124\",\n      archivePrefix  = \"arXiv\",\n      primaryClass   = \"hep-ph\",\n      reportNumber   = \"MIT-CTP-4965\"\n}\n\n\n\n\nWhy Python instead of C++?\n\n\nComputing the energy flow polynomials requires a function such as NumPy's \neinsum\n that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use.\n\n\nNumPy\n is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the energy flow polynomials. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and features such as SSE instructions.\n\n\nCan I contribute to the code?\n\n\nAll of our code is open source and hosted on \nGitHub\n. We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository.\n\n\nHow do I report an issue?\n\n\nPlease let us know of any issues you encounter as soon as possible by creating an \nIssue\n on the EnergyFlow GitHub repository. \n\n\nWhere can I get graph image files?\n\n\nImage files for all connected multigraphs with up to 7 edges in the energy flow polynomial style are available as pdf files \nhere\n. You are free to use them with the proper attribution.",
            "title": "FAQ"
        },
        {
            "location": "/faq/#frequently-asked-energyflow-questions",
            "text": "How do I cite the EnergyFlow package?  Why Python instead of C++?  Can I contribute to the code?  How do I report an issue or a bug?  Where can I get graph image files?",
            "title": "Frequently Asked EnergyFlow Questions"
        },
        {
            "location": "/faq/#how-do-i-cite-the-energyflow-package",
            "text": "Please cite the relevant Energy Flow papers if they or this package helps your research. Here are the BibTeX entries to use:  @article{Komiske:2017aww,\n      author         = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\",\n      title          = \"{Energy Flow Polynomials: A complete linear basis for jet substructure}\",\n      journal        = \"JHEP\",\n      volume         = \"04\",\n      year           = \"2018\",\n      pages          = \"013\",\n      doi            = \"10.1007/JHEP04(2018)013\",\n      eprint         = \"1712.07124\",\n      archivePrefix  = \"arXiv\",\n      primaryClass   = \"hep-ph\",\n      reportNumber   = \"MIT-CTP-4965\"\n}",
            "title": "How do I cite the EnergyFlow package?"
        },
        {
            "location": "/faq/#why-python-instead-of-c",
            "text": "Computing the energy flow polynomials requires a function such as NumPy's  einsum  that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use.  NumPy  is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the energy flow polynomials. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and features such as SSE instructions.",
            "title": "Why Python instead of C++?"
        },
        {
            "location": "/faq/#can-i-contribute-to-the-code",
            "text": "All of our code is open source and hosted on  GitHub . We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository.",
            "title": "Can I contribute to the code?"
        },
        {
            "location": "/faq/#how-do-i-report-an-issue",
            "text": "Please let us know of any issues you encounter as soon as possible by creating an  Issue  on the EnergyFlow GitHub repository.",
            "title": "How do I report an issue?"
        },
        {
            "location": "/faq/#where-can-i-get-graph-image-files",
            "text": "Image files for all connected multigraphs with up to 7 edges in the energy flow polynomial style are available as pdf files  here . You are free to use them with the proper attribution.",
            "title": "Where can I get graph image files?"
        },
        {
            "location": "/docs/measure/",
            "text": "Energy and Angular Measures\n\n\nThe appropriate notions of energy and angle depend on the collider context. Typically, one wants\nto work with observables that respect the appropriate Lorentz subgroup for the collision type\nof interest. EnergyFlow is capable of handling two broad classes of measures: $e^+e^-$ and\nhadronic, which are selected using the \nmeasure\n keyword argument (default is \n'hadrdot'\n).\nFor substructure applications, it is often convenient to normalize the energies so that\n$\\sum_iz_i=1$. The \nnormed\n keyword argument is provided to control normalization of the\nenergies (default is \nTrue\n).\n\n\nEach measure comes with a parameter $\\beta>0$ which controls the relative weighting between\nsmaller and larger anglular structures. This can be set using the \nbeta\n keyword argument\n(default is \n2\n). There is also a $\\kappa$ parameter to control the relative weighting\nbetween soft and hard energies. This can be set using the \nkappa\n keyword argument\n(default is \n1\n). Only \nkappa=1\n yields collinear-safe observables.\n\n\nBeyond the measures implemented here, the user can implement their own custom measure by\npassing ${z_i}$ and ${\\theta_{ij}}$ in directly to the EFP classes.\n\n\nHadronic Measures\n\n\nFor hadronic collisions, observables are typically desired to be invariant under boosts along\nthe beam direction and rotations about the beam direction. Thus, particle transverse momentum\n$p_T$ and rapidity-azimuth coordinates $(y,\\phi)$ are often used.\n\n\nThere are two hadronic measures implemented in EnergyFlow: \n'hadr'\n and \n'hadrdot'\n (the default).\nThese are listed explicitly below.\n\n\n'hadr'\n:\n\nz_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=(\\Delta y_{ij}^2 + \\Delta\\phi_{ij}^2)^{\\beta/2}.\n\n\n\n\n'hadrdot'\n:\n\nz_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=\\left(\\frac{2p^\\mu_ip_{j\\mu}}{p_{T,i}p_{T,j}}\n\\right)^{\\beta/2}.\n\n\n\n\ne+e-\n Measures\n\n\nFor $e^+e^-$ collisions, observables are typically desired to be invariant under the full\ngroup of reotations about the interaction point. Since the center of momentum energy is known,\nthe particle energy $E$ is typically used. For the angular measure, pairwise Lorentz contractions\nof the normalized particle four-momenta are used.\n\n\nThere is one $e^+e^-$ measure implemented in the EnergyFlow framework.\n\n\n'ee'\n:\n\nz_i = E_{i}^{\\kappa},\n\\quad\\quad \\theta_{ij} = \\left(\\frac{2p_i^\\mu p_{j \\mu}}{E_i E_j}\\right)^{\\beta/2}.\n\n\n\n\n\n\nMeasure\n\n\nClass for dealing with any kind of measure.\n\n\nenergyflow.Measure(measure, beta=1, kappa=1, normed=True, check_input=True)\n\n\n\n\nProcesses inputs according to the measure choice.\n\n\nArguments\n\n\n\n\n\n\nmeasure\n : \nstring\n\n\n\n\nThe string specifying the energy and angular measures to use.\n\n\n\n\n\n\n\n\nbeta\n : \nfloat\n or 'pf'\n\n\n\n\nThe angular weighting exponent $\\beta$. Must be positive.\n\n\n\n\n\n\n\n\nkappa\n : \nfloat\n\n\n\n\nIf a number, the energy weighting exponent $\\kappa$. If \n'pf'\n, use $\\kappa=v$\n where $v$ is the valency of the vertex. \n'pf'\n can be used with measure except \n'hadr'\n.\n Only IRC-safe for \nkappa=1\n.\n\n\n\n\n\n\n\n\nnormed\n : bool\n\n\n\n\nWhether or not to use normalized energies\n\n\n\n\n\n\n\n\ncheck_input\n : bool\n\n\n\n\nWhether to check the type of input each time or assume the first input type.\n\n\n\n\n\n\n\n\nevaluate\n\n\nevaluate(arg)\n\n\n\n\nEvaluate",
            "title": "Measures"
        },
        {
            "location": "/docs/measure/#energy-and-angular-measures",
            "text": "The appropriate notions of energy and angle depend on the collider context. Typically, one wants\nto work with observables that respect the appropriate Lorentz subgroup for the collision type\nof interest. EnergyFlow is capable of handling two broad classes of measures: $e^+e^-$ and\nhadronic, which are selected using the  measure  keyword argument (default is  'hadrdot' ).\nFor substructure applications, it is often convenient to normalize the energies so that\n$\\sum_iz_i=1$. The  normed  keyword argument is provided to control normalization of the\nenergies (default is  True ).  Each measure comes with a parameter $\\beta>0$ which controls the relative weighting between\nsmaller and larger anglular structures. This can be set using the  beta  keyword argument\n(default is  2 ). There is also a $\\kappa$ parameter to control the relative weighting\nbetween soft and hard energies. This can be set using the  kappa  keyword argument\n(default is  1 ). Only  kappa=1  yields collinear-safe observables.  Beyond the measures implemented here, the user can implement their own custom measure by\npassing ${z_i}$ and ${\\theta_{ij}}$ in directly to the EFP classes.",
            "title": "Energy and Angular Measures"
        },
        {
            "location": "/docs/measure/#hadronic-measures",
            "text": "For hadronic collisions, observables are typically desired to be invariant under boosts along\nthe beam direction and rotations about the beam direction. Thus, particle transverse momentum\n$p_T$ and rapidity-azimuth coordinates $(y,\\phi)$ are often used.  There are two hadronic measures implemented in EnergyFlow:  'hadr'  and  'hadrdot'  (the default).\nThese are listed explicitly below.  'hadr' : z_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=(\\Delta y_{ij}^2 + \\Delta\\phi_{ij}^2)^{\\beta/2}.   'hadrdot' : z_i=p_{T,i}^{\\kappa},\\quad\\quad \\theta_{ij}=\\left(\\frac{2p^\\mu_ip_{j\\mu}}{p_{T,i}p_{T,j}}\n\\right)^{\\beta/2}.",
            "title": "Hadronic Measures"
        },
        {
            "location": "/docs/measure/#ee-measures",
            "text": "For $e^+e^-$ collisions, observables are typically desired to be invariant under the full\ngroup of reotations about the interaction point. Since the center of momentum energy is known,\nthe particle energy $E$ is typically used. For the angular measure, pairwise Lorentz contractions\nof the normalized particle four-momenta are used.  There is one $e^+e^-$ measure implemented in the EnergyFlow framework.  'ee' : z_i = E_{i}^{\\kappa},\n\\quad\\quad \\theta_{ij} = \\left(\\frac{2p_i^\\mu p_{j \\mu}}{E_i E_j}\\right)^{\\beta/2}.",
            "title": "e+e- Measures"
        },
        {
            "location": "/docs/measure/#measure",
            "text": "Class for dealing with any kind of measure.  energyflow.Measure(measure, beta=1, kappa=1, normed=True, check_input=True)  Processes inputs according to the measure choice.  Arguments    measure  :  string   The string specifying the energy and angular measures to use.     beta  :  float  or 'pf'   The angular weighting exponent $\\beta$. Must be positive.     kappa  :  float   If a number, the energy weighting exponent $\\kappa$. If  'pf' , use $\\kappa=v$\n where $v$ is the valency of the vertex.  'pf'  can be used with measure except  'hadr' .\n Only IRC-safe for  kappa=1 .     normed  : bool   Whether or not to use normalized energies     check_input  : bool   Whether to check the type of input each time or assume the first input type.",
            "title": "Measure"
        },
        {
            "location": "/docs/measure/#evaluate",
            "text": "evaluate(arg)  Evaluate",
            "title": "evaluate"
        },
        {
            "location": "/docs/gen/",
            "text": "Implementation of EFP/EFM Generator class.\n\n\n\n\nGenerator\n\n\nGenerates non-isomorphic multigraphs according to provided specifications.\n\n\nenergyflow.Generator(dmax=None, nmax=None, emax=None, cmax=None, vmax=None, comp_dmaxs=None, filename=None, gen_efms=True, ve_alg='numpy', np_optimize='greedy', verbose=False)\n\n\n\n\nDoing a fresh generation of connected multigraphs (\nfilename=None\n) requires\nthat \nigraph\n be installed.\n\n\nArguments\n\n\n\n\ndmax\n : \nint\n\n\nThe maximum number of edges of the generated connected graphs.\n\n\n\n\n\n\nnmax\n : \nint\n\n\nThe maximum number of vertices of the generated connected graphs.\n\n\n\n\n\n\nemax\n : \nint\n\n\nThe maximum number of edges of the generated connected simple graphs.\n\n\n\n\n\n\ncmax\n : \nint\n\n\nThe maximum VE complexity $\\chi$ of the generated connected graphs.\n\n\n\n\n\n\nvmax\n : \nint\n\n\nThe maximum valency of the generated connected graphs.\n\n\n\n\n\n\ncomp_dmaxs\n : {\ndict\n, \nint\n}\n\n\nIf an integer, the maximum number of edges of the generated disconnected \ngraphs. If a dictionary, the keys are numbers of vertices and the values are\nthe maximum number of edges of the generated disconnected graphs with that\nnumber of vertices.\n\n\n\n\n\n\nfilename\n : \nstr\n\n\nIf \nNone\n, do a complete generation from scratch. If set to a string, \nread in connected graphs from the file given, restrict them according to \nthe various 'max' parameters, and do a fresh disconnected generation. The special\nvalue \nfilename='default'\n means to read in graphs from the default file. This\nis useful when various disconnected graph parameters are to be varied since the \ngeneration of large simple graphs is the most computationlly intensive part.\n\n\n\n\n\n\ngen_efms\n : \nbool\n\n\nControls whether EFM information is generated.\n\n\n\n\n\n\nve_alg\n : {\n'numpy'\n, \n'ef'\n}\n\n\nWhich variable elimination algorithm to use.\n\n\n\n\n\n\nnp_optimize\n : {\nTrue\n, \nFalse\n, \n'greedy'\n, \n'optimal'\n}\n\n\nWhen \nve_alg='numpy'\n this is the \noptimize\n keyword\nof \nnumpy.einsum_path\n.\n\n\n\n\n\n\nverbose\n : \nbool\n\n\nA flag to control printing.\n\n\n\n\n\n\n\n\nsave\n\n\nsave(filename)\n\n\n\n\nSave the current generator to file.\n\n\nArguments\n\n\n\n\nfilename\n : \nstr\n\n\nThe path to save the file.\n\n\n\n\n\n\n\n\nspecs\n\n\nspecs\n\n\n\n\nAn array of EFP specifications. Each row represents an EFP \nand the columns represent the quantities indicated by \ncols\n.",
            "title": "Generation"
        },
        {
            "location": "/docs/gen/#generator",
            "text": "Generates non-isomorphic multigraphs according to provided specifications.  energyflow.Generator(dmax=None, nmax=None, emax=None, cmax=None, vmax=None, comp_dmaxs=None, filename=None, gen_efms=True, ve_alg='numpy', np_optimize='greedy', verbose=False)  Doing a fresh generation of connected multigraphs ( filename=None ) requires\nthat  igraph  be installed.  Arguments   dmax  :  int  The maximum number of edges of the generated connected graphs.    nmax  :  int  The maximum number of vertices of the generated connected graphs.    emax  :  int  The maximum number of edges of the generated connected simple graphs.    cmax  :  int  The maximum VE complexity $\\chi$ of the generated connected graphs.    vmax  :  int  The maximum valency of the generated connected graphs.    comp_dmaxs  : { dict ,  int }  If an integer, the maximum number of edges of the generated disconnected \ngraphs. If a dictionary, the keys are numbers of vertices and the values are\nthe maximum number of edges of the generated disconnected graphs with that\nnumber of vertices.    filename  :  str  If  None , do a complete generation from scratch. If set to a string, \nread in connected graphs from the file given, restrict them according to \nthe various 'max' parameters, and do a fresh disconnected generation. The special\nvalue  filename='default'  means to read in graphs from the default file. This\nis useful when various disconnected graph parameters are to be varied since the \ngeneration of large simple graphs is the most computationlly intensive part.    gen_efms  :  bool  Controls whether EFM information is generated.    ve_alg  : { 'numpy' ,  'ef' }  Which variable elimination algorithm to use.    np_optimize  : { True ,  False ,  'greedy' ,  'optimal' }  When  ve_alg='numpy'  this is the  optimize  keyword\nof  numpy.einsum_path .    verbose  :  bool  A flag to control printing.",
            "title": "Generator"
        },
        {
            "location": "/docs/gen/#save",
            "text": "save(filename)  Save the current generator to file.  Arguments   filename  :  str  The path to save the file.",
            "title": "save"
        },
        {
            "location": "/docs/gen/#specs",
            "text": "specs  An array of EFP specifications. Each row represents an EFP \nand the columns represent the quantities indicated by  cols .",
            "title": "specs"
        },
        {
            "location": "/docs/efp/",
            "text": "Energy Flow Polynomials (EFPs) are a set of observables, indexed by non-isomorphic \nmultigraphs, which linearly span the space of infrared and collinear safe (IRC-safe) \nobservables.\n\n\nAn EFP index by a multigraph $G$ takes the following form:\n\n\\text{EFP}_G=\\sum_{i_1=1}^M\\cdots\\sum_{i_N=1}^Mz_{i_1}\\cdots z_{i_N}\n\\prod_{(k,\\ell)\\in G}\\theta_{i_ki_\\ell}\n\nwhere $z_i$ is a measure of the energy of particle $i$ and $\\theta_{ij}$ is a measure \nof the angular separation between particles $i$ and $j$. The specific choices for energy \nand angular measure depend on the collider context and are discussed at length in the \n\nMeasures\n section.\n\n\n\n\nEFP\n\n\nA class for representing and computing a single EFP.\n\n\nenergyflow.EFP(edges, measure='hadrdot', beta=1, kappa=1, normed=True, check_input=True, ve_alg='numpy', np_optimize='greedy', M_thresh=None)\n\n\n\n\nArguments\n\n\n\n\nedges\n : \nlist\n\n\nEdges of the EFP graph specified by pairs of vertices.\n\n\n\n\n\n\nmeasure\n : {\n'hadr'\n, \n'hadrdot'\n, \n'hadrefm'\n, \n'ee'\n, \n'eeefm'\n}\n\n\nSee \nMeasures\n for additional info.\n\n\n\n\n\n\nbeta\n : \nfloat\n\n\nThe parameter $\\beta$ appearing in the measure.\nMust be greater than zero.\n\n\n\n\n\n\nkappa\n : {\nfloat\n, \n'pf'\n}\n\n\nIf a number, the energy weighting parameter $\\kappa$.\nIf \n'pf'\n, use $\\kappa=v-1$ where $v$ is the valency of the vertex.\n\n\n\n\n\n\nnormed\n : \nbool\n\n\nControls normalization of the energies in the measure.\n\n\n\n\n\n\ncheck_input\n : \nbool\n\n\nWhether to check the type of the input each time or assume\nthe first input type.\n\n\n\n\n\n\nve_alg\n : {\n'numpy'\n, \n'ef'\n}\n\n\nWhich variable elimination algorithm to use.\n\n\n\n\n\n\nnp_optimize\n : {\nTrue\n, \nFalse\n, \n'greedy'\n, \n'optimal'\n}\n\n\nWhen \nve_alg='numpy'\n this is the \noptimize\n keyword\nof \nnumpy.einsum_path\n.\n\n\n\n\n\n\n\n\ncompute\n\n\ncompute(event=None, zs=None, thetas=None, ps=None)\n\n\n\n\nComputes the value(s) of the EFP(s) on a single event.\n\n\nArguments\n\n\n\n\nevent\n : array_like or \nfastjet.PseudoJet\n\n\nThe event as an array of \n[E,px,py,pz]\n or \n[pT,y,phi]\n (if hadronic).\n\n\n\n\n\n\nzs\n : 1-dim array_like\n\n\nIf present, \nthetas\n must also be present, and \nzs\n is used in place \nof the energies of an event.\n\n\n\n\n\n\nthetas\n : 2-dim array_like\n\n\nIf present, \nzs\n must also be present, and \nthetas\n is used in place \nof the pairwise angles of an event.\n\n\n\n\n\n\nps\n : \nnumpy.ndarray\n\n\nIf present, used in place of the dim-vectors returned by the measure\nwhen using EFMs.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nThe answers\n\n\n\n\n\n\n\n\nbatch_compute\n\n\nbatch_compute(events, n_jobs=-1)\n\n\n\n\nComputes the value(s) of the EFP(s) on several events.\n\n\nArguments\n\n\n\n\nevents\n : array_like or \nfastjet.PseudoJet\n\n\nThe events as an array of arrays of \n[E,px,py,pz]\n or \n[pT,y,phi]\n \n(if hadronic).\n\n\n\n\n\n\nn_jobs\n : int\n\n\nThe number of worker processes to use. A value of \n-1\n will attempt\nto use as many processes as there are CPUs on the machine.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nThe answers\n\n\n\n\n\n\n\n\ngraph\n\n\ngraph\n\n\n\n\nGraph of this EFP represented by a list of edges.\n\n\nsimple_graph\n\n\nsimple_graph\n\n\n\n\nSimple graph of this EFP (forgetting all multiedges)\nrepresented by a list of edges.\n\n\nn\n\n\nn\n\n\n\n\nNumber of vertices in the graph of this EFP.\n\n\nd\n\n\nd\n\n\n\n\nDegree, or number of edges, in the graph of this EFP.\n\n\nc\n\n\nc\n\n\n\n\nVE complexity $\\chi$ of this EFP.\n\n\nefmset\n\n\nefmset\n\n\n\n\nInstance of \nEFMSet\n help by this EFP.\n\n\n\n\nEFPSet\n\n\nA class that holds a collection of EFPs and computes their values on events.\n\n\nenergyflow.EFPSet(*args, filename=None, measure='hadrdot', beta=1, kappa=1, normed=True, check_input=True, verbose=False)\n\n\n\n\nEFPSet can be initialized in one of three ways (in order of precedence):\n\n\n\n\nDefault\n - Use the EFPs that come installed with the\n\nEnergFlow\n package.\n\n\nGenerator\n - Pass in a custom \nGenerator\n object as the\nfirst positional argument.\n\n\nCustom File\n - Pass in the name of a \n.npz\n file saved\nwith a custom \nGenerator\n.\n\n\n\n\nTo control which EFPs are included, \nEFPSet\n accepts an arbitrary\nnumber of specifications (see \nsel\n) and only EFPs meeting each\nspecification are included in the set.\n\n\nArguments\n\n\n\n\n*args\n : \narbitrary positional arguments\n\n\nIf the first positional argument is a \nGenerator\n instance,\nit is used for initialization. The remaining positional\narguments must be valid arguments to \nsel\n.\n\n\n\n\n\n\nfilename\n : \nstring\n\n\nPath to a \n.npz\n file which has been saved by a valid\n\nenergyflow.Generator\n.\n\n\n\n\n\n\nmeasure\n : {\n'hadr'\n, \n'hadr-dot'\n, \n'ee'\n}\n\n\nSee \nMeasures\n for additional info.\n\n\n\n\n\n\nbeta\n : \nfloat\n\n\nThe parameter $\\beta$ appearing in the measure.\nMust be greater than zero.\n\n\n\n\n\n\nkappa\n : {\nfloat\n, \n'pf'\n}\n\n\nIf a number, the energy weighting parameter $\\kappa$.\nIf \n'pf'\n, use $\\kappa=v-1$ where $v$ is the valency of the vertex.\n\n\n\n\n\n\nnormed\n : \nbool\n\n\nControls normalization of the energies in the measure.\n\n\n\n\n\n\ncheck_type\n : \nbool\n\n\nWhether to check the type of the input each time or use\nthe first input type.\n\n\n\n\n\n\nverbose\n : \nbool\n\n\nControls printed output when initializing EFPSet.\n\n\n\n\n\n\n\n\ncompute\n\n\ncompute(event=None, zs=None, thetas=None, ps=None)\n\n\n\n\nComputes the value(s) of the EFP(s) on a single event.\n\n\nArguments\n\n\n\n\nevent\n : array_like or \nfastjet.PseudoJet\n\n\nThe event as an array of \n[E,px,py,pz]\n or \n[pT,y,phi]\n (if hadronic).\n\n\n\n\n\n\nzs\n : 1-dim array_like\n\n\nIf present, \nthetas\n must also be present, and \nzs\n is used in place \nof the energies of an event.\n\n\n\n\n\n\nthetas\n : 2-dim array_like\n\n\nIf present, \nzs\n must also be present, and \nthetas\n is used in place \nof the pairwise angles of an event.\n\n\n\n\n\n\nps\n : \nnumpy.ndarray\n\n\nIf present, used in place of the dim-vectors returned by the measure\nwhen using EFMs.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nThe answers\n\n\n\n\n\n\n\n\nbatch_compute\n\n\nbatch_compute(events, n_jobs=-1)\n\n\n\n\nComputes the value(s) of the EFP(s) on several events.\n\n\nArguments\n\n\n\n\nevents\n : array_like or \nfastjet.PseudoJet\n\n\nThe events as an array of arrays of \n[E,px,py,pz]\n or \n[pT,y,phi]\n \n(if hadronic).\n\n\n\n\n\n\nn_jobs\n : int\n\n\nThe number of worker processes to use. A value of \n-1\n will attempt\nto use as many processes as there are CPUs on the machine.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nThe answers\n\n\n\n\n\n\n\n\ncalc_disc\n\n\ncalc_disc(X)\n\n\n\n\nComputes disconnected EFPs according to the internal \nspecifications using the connected EFPs provided as input.\n\n\nArguments\n\n\n\n\nX\n : \nnumpy.ndarray\n\n\nArray of connected EFPs. Rows are different events, columns \nare the different EFPs. Can handle a single event (a 1-dim array) \nas input. EFPs are assumed to be in the order expected by the \ninstance of \nEFPSet\n; the safest way to ensure this is to use \nthe same \nEFPSet\n to calculate both connected and disconnected \nEFPs. This function is used internally in \ncompute\n and \n\nbatch_compute\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nA concatenated array of the connected and disconnected EFPs.\n\n\n\n\n\n\n\n\nsel\n\n\nsel(*args)\n\n\n\n\nComputes a boolean mask of EFPs matching each of the\nspecifications provided by the \nargs\n. \n\n\nArguments\n\n\n\n\n*args\n : arbitrary positional arguments\n\n\nEach argument can be either a string or a length-two \niterable. If the argument is a string, it should consist \nof three parts: a character which is a valid element of \n\ncols\n, a comparison operator (one of \n<\n, \n>\n, \n<=\n, \n\n>=\n, \n==\n, \n!=\n), and a number. Whitespace between the \nparts does not matter. If the argument is a tuple, the \nfirst element should be a string containing a column \nheader character and a comparison operator; the second \nelement is the value to be compared. The tuple version \nis useful when the value is a variable that changes \n(such as in a list comprehension).\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nA boolean array of length the number of EFPs stored by this object. \n\n\n\n\n\n\n\n\ncount\n\n\ncount(*args)\n\n\n\n\nCounts the number of EFPs meeting the specifications\nof the arguments using \nsel\n.\n\n\nArguments\n \n\n\n\n\n*args\n : arbitrary positional arguments\n\n\nValid arguments to be passed to \nsel\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nint\n\n\nThe number of EFPs meeting the specifications provided.\n\n\n\n\n\n\n\n\ngraphs\n\n\ngraphs(*args)\n\n\n\n\nGraphs meeting provided specifications.\n\n\nArguments\n \n\n\n\n\n*args\n : arbitrary positional arguments\n\n\nValid arguments to be passed to \nsel\n, or, if a single integer, \nthe index of a particular graph.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nlist\n, if single integer argument is given\n\n\nThe list of edges corresponding to the specified graph\n\n\n\n\n\n\nnumpy.ndarray\n, otherwise\n\n\nAn array of graphs (as lists of edges) matching the specifications.\n\n\n\n\n\n\n\n\nsimple_graphs\n\n\nsimple_graphs(*args)\n\n\n\n\nSimple graphs meeting provided specifications.\n\n\nArguments\n \n\n\n\n\n*args\n : arbitrary positional arguments\n\n\nValid arguments to be passed to \nsel\n, or, if a single integer, \nthe index of particular simple graph.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nlist\n, if single integer argument is given\n\n\nThe list of edges corresponding to the specified simple graph\n\n\n\n\n\n\nnumpy.ndarray\n, otherwise\n\n\nAn array of simple graphs (as lists of edges) matching the specifications.\n\n\n\n\n\n\n\n\nspecs\n\n\nspecs\n\n\n\n\nAn array of EFP specifications. Each row represents an EFP \nand the columns represent the quantities indicated by \ncols\n.\n\n\ncspecs\n\n\ncspecs\n\n\n\n\nSpecification array for connected EFPs.\n\n\ncols\n\n\ncols\n\n\n\n\nColumn labels for \nspecs\n. \nThose of primary interest are listed below.\n\n\n\n\nn\n : Number of vertices.\n\n\ne\n : Number of simple edges.\n\n\nd\n : Degree, or number of multiedges.\n\n\nv\n : Maximum valency (number of edges touching a vertex).\n\n\nk\n : Unique identifier within EFPs of this (n,d).\n\n\nc\n : VE complexity $\\chi$.\n\n\np\n : Number of prime factors (or connected components).\n\n\nh\n : Number of valency 1 vertices (a.k.a. 'hanging chads').\n\n\n\n\nefmsets\n\n\nefmsets\n\n\n\n\nThe \nEFMset\ns held by this object, if using EFMs.",
            "title": "Energy Flow Polynomials"
        },
        {
            "location": "/docs/efp/#efp",
            "text": "A class for representing and computing a single EFP.  energyflow.EFP(edges, measure='hadrdot', beta=1, kappa=1, normed=True, check_input=True, ve_alg='numpy', np_optimize='greedy', M_thresh=None)  Arguments   edges  :  list  Edges of the EFP graph specified by pairs of vertices.    measure  : { 'hadr' ,  'hadrdot' ,  'hadrefm' ,  'ee' ,  'eeefm' }  See  Measures  for additional info.    beta  :  float  The parameter $\\beta$ appearing in the measure.\nMust be greater than zero.    kappa  : { float ,  'pf' }  If a number, the energy weighting parameter $\\kappa$.\nIf  'pf' , use $\\kappa=v-1$ where $v$ is the valency of the vertex.    normed  :  bool  Controls normalization of the energies in the measure.    check_input  :  bool  Whether to check the type of the input each time or assume\nthe first input type.    ve_alg  : { 'numpy' ,  'ef' }  Which variable elimination algorithm to use.    np_optimize  : { True ,  False ,  'greedy' ,  'optimal' }  When  ve_alg='numpy'  this is the  optimize  keyword\nof  numpy.einsum_path .",
            "title": "EFP"
        },
        {
            "location": "/docs/efp/#compute",
            "text": "compute(event=None, zs=None, thetas=None, ps=None)  Computes the value(s) of the EFP(s) on a single event.  Arguments   event  : array_like or  fastjet.PseudoJet  The event as an array of  [E,px,py,pz]  or  [pT,y,phi]  (if hadronic).    zs  : 1-dim array_like  If present,  thetas  must also be present, and  zs  is used in place \nof the energies of an event.    thetas  : 2-dim array_like  If present,  zs  must also be present, and  thetas  is used in place \nof the pairwise angles of an event.    ps  :  numpy.ndarray  If present, used in place of the dim-vectors returned by the measure\nwhen using EFMs.     Returns   numpy.ndarray  The answers",
            "title": "compute"
        },
        {
            "location": "/docs/efp/#batch_compute",
            "text": "batch_compute(events, n_jobs=-1)  Computes the value(s) of the EFP(s) on several events.  Arguments   events  : array_like or  fastjet.PseudoJet  The events as an array of arrays of  [E,px,py,pz]  or  [pT,y,phi]  \n(if hadronic).    n_jobs  : int  The number of worker processes to use. A value of  -1  will attempt\nto use as many processes as there are CPUs on the machine.     Returns   numpy.ndarray  The answers",
            "title": "batch_compute"
        },
        {
            "location": "/docs/efp/#graph",
            "text": "graph  Graph of this EFP represented by a list of edges.",
            "title": "graph"
        },
        {
            "location": "/docs/efp/#simple_graph",
            "text": "simple_graph  Simple graph of this EFP (forgetting all multiedges)\nrepresented by a list of edges.",
            "title": "simple_graph"
        },
        {
            "location": "/docs/efp/#n",
            "text": "n  Number of vertices in the graph of this EFP.",
            "title": "n"
        },
        {
            "location": "/docs/efp/#d",
            "text": "d  Degree, or number of edges, in the graph of this EFP.",
            "title": "d"
        },
        {
            "location": "/docs/efp/#c",
            "text": "c  VE complexity $\\chi$ of this EFP.",
            "title": "c"
        },
        {
            "location": "/docs/efp/#efmset",
            "text": "efmset  Instance of  EFMSet  help by this EFP.",
            "title": "efmset"
        },
        {
            "location": "/docs/efp/#efpset",
            "text": "A class that holds a collection of EFPs and computes their values on events.  energyflow.EFPSet(*args, filename=None, measure='hadrdot', beta=1, kappa=1, normed=True, check_input=True, verbose=False)  EFPSet can be initialized in one of three ways (in order of precedence):   Default  - Use the EFPs that come installed with the EnergFlow  package.  Generator  - Pass in a custom  Generator  object as the\nfirst positional argument.  Custom File  - Pass in the name of a  .npz  file saved\nwith a custom  Generator .   To control which EFPs are included,  EFPSet  accepts an arbitrary\nnumber of specifications (see  sel ) and only EFPs meeting each\nspecification are included in the set.  Arguments   *args  :  arbitrary positional arguments  If the first positional argument is a  Generator  instance,\nit is used for initialization. The remaining positional\narguments must be valid arguments to  sel .    filename  :  string  Path to a  .npz  file which has been saved by a valid energyflow.Generator .    measure  : { 'hadr' ,  'hadr-dot' ,  'ee' }  See  Measures  for additional info.    beta  :  float  The parameter $\\beta$ appearing in the measure.\nMust be greater than zero.    kappa  : { float ,  'pf' }  If a number, the energy weighting parameter $\\kappa$.\nIf  'pf' , use $\\kappa=v-1$ where $v$ is the valency of the vertex.    normed  :  bool  Controls normalization of the energies in the measure.    check_type  :  bool  Whether to check the type of the input each time or use\nthe first input type.    verbose  :  bool  Controls printed output when initializing EFPSet.",
            "title": "EFPSet"
        },
        {
            "location": "/docs/efp/#compute_1",
            "text": "compute(event=None, zs=None, thetas=None, ps=None)  Computes the value(s) of the EFP(s) on a single event.  Arguments   event  : array_like or  fastjet.PseudoJet  The event as an array of  [E,px,py,pz]  or  [pT,y,phi]  (if hadronic).    zs  : 1-dim array_like  If present,  thetas  must also be present, and  zs  is used in place \nof the energies of an event.    thetas  : 2-dim array_like  If present,  zs  must also be present, and  thetas  is used in place \nof the pairwise angles of an event.    ps  :  numpy.ndarray  If present, used in place of the dim-vectors returned by the measure\nwhen using EFMs.     Returns   numpy.ndarray  The answers",
            "title": "compute"
        },
        {
            "location": "/docs/efp/#batch_compute_1",
            "text": "batch_compute(events, n_jobs=-1)  Computes the value(s) of the EFP(s) on several events.  Arguments   events  : array_like or  fastjet.PseudoJet  The events as an array of arrays of  [E,px,py,pz]  or  [pT,y,phi]  \n(if hadronic).    n_jobs  : int  The number of worker processes to use. A value of  -1  will attempt\nto use as many processes as there are CPUs on the machine.     Returns   numpy.ndarray  The answers",
            "title": "batch_compute"
        },
        {
            "location": "/docs/efp/#calc_disc",
            "text": "calc_disc(X)  Computes disconnected EFPs according to the internal \nspecifications using the connected EFPs provided as input.  Arguments   X  :  numpy.ndarray  Array of connected EFPs. Rows are different events, columns \nare the different EFPs. Can handle a single event (a 1-dim array) \nas input. EFPs are assumed to be in the order expected by the \ninstance of  EFPSet ; the safest way to ensure this is to use \nthe same  EFPSet  to calculate both connected and disconnected \nEFPs. This function is used internally in  compute  and  batch_compute .     Returns   numpy.ndarray  A concatenated array of the connected and disconnected EFPs.",
            "title": "calc_disc"
        },
        {
            "location": "/docs/efp/#sel",
            "text": "sel(*args)  Computes a boolean mask of EFPs matching each of the\nspecifications provided by the  args .   Arguments   *args  : arbitrary positional arguments  Each argument can be either a string or a length-two \niterable. If the argument is a string, it should consist \nof three parts: a character which is a valid element of  cols , a comparison operator (one of  < ,  > ,  <= ,  >= ,  == ,  != ), and a number. Whitespace between the \nparts does not matter. If the argument is a tuple, the \nfirst element should be a string containing a column \nheader character and a comparison operator; the second \nelement is the value to be compared. The tuple version \nis useful when the value is a variable that changes \n(such as in a list comprehension).     Returns   numpy.ndarray  A boolean array of length the number of EFPs stored by this object.",
            "title": "sel"
        },
        {
            "location": "/docs/efp/#count",
            "text": "count(*args)  Counts the number of EFPs meeting the specifications\nof the arguments using  sel .  Arguments     *args  : arbitrary positional arguments  Valid arguments to be passed to  sel .     Returns   int  The number of EFPs meeting the specifications provided.",
            "title": "count"
        },
        {
            "location": "/docs/efp/#graphs",
            "text": "graphs(*args)  Graphs meeting provided specifications.  Arguments     *args  : arbitrary positional arguments  Valid arguments to be passed to  sel , or, if a single integer, \nthe index of a particular graph.     Returns   list , if single integer argument is given  The list of edges corresponding to the specified graph    numpy.ndarray , otherwise  An array of graphs (as lists of edges) matching the specifications.",
            "title": "graphs"
        },
        {
            "location": "/docs/efp/#simple_graphs",
            "text": "simple_graphs(*args)  Simple graphs meeting provided specifications.  Arguments     *args  : arbitrary positional arguments  Valid arguments to be passed to  sel , or, if a single integer, \nthe index of particular simple graph.     Returns   list , if single integer argument is given  The list of edges corresponding to the specified simple graph    numpy.ndarray , otherwise  An array of simple graphs (as lists of edges) matching the specifications.",
            "title": "simple_graphs"
        },
        {
            "location": "/docs/efp/#specs",
            "text": "specs  An array of EFP specifications. Each row represents an EFP \nand the columns represent the quantities indicated by  cols .",
            "title": "specs"
        },
        {
            "location": "/docs/efp/#cspecs",
            "text": "cspecs  Specification array for connected EFPs.",
            "title": "cspecs"
        },
        {
            "location": "/docs/efp/#cols",
            "text": "cols  Column labels for  specs . \nThose of primary interest are listed below.   n  : Number of vertices.  e  : Number of simple edges.  d  : Degree, or number of multiedges.  v  : Maximum valency (number of edges touching a vertex).  k  : Unique identifier within EFPs of this (n,d).  c  : VE complexity $\\chi$.  p  : Number of prime factors (or connected components).  h  : Number of valency 1 vertices (a.k.a. 'hanging chads').",
            "title": "cols"
        },
        {
            "location": "/docs/efp/#efmsets",
            "text": "efmsets  The  EFMset s held by this object, if using EFMs.",
            "title": "efmsets"
        },
        {
            "location": "/docs/efm/",
            "text": "Under Construction\n\n\n\n\nEFM\n\n\nenergyflow.EFM(nlow, nup, raw=False, rlfrom=None, subslicefrom=None)\n\n\n\n\nA class representing a single EFM\n\n\n\n\nEFMSet\n\n\nenergyflow.EFMSet(efm_specs, subslicing=False, max_v=None)\n\n\n\n\nA collection of EFMs\n\n\n\n\nefp2efms\n\n\nenergyflow.efp2efms(graph)\n\n\n\n\nThis function converts an EFP to an EFM formula.",
            "title": "Energy Flow Moments"
        },
        {
            "location": "/docs/efm/#efm",
            "text": "energyflow.EFM(nlow, nup, raw=False, rlfrom=None, subslicefrom=None)  A class representing a single EFM",
            "title": "EFM"
        },
        {
            "location": "/docs/efm/#efmset",
            "text": "energyflow.EFMSet(efm_specs, subslicing=False, max_v=None)  A collection of EFMs",
            "title": "EFMSet"
        },
        {
            "location": "/docs/efm/#efp2efms",
            "text": "energyflow.efp2efms(graph)  This function converts an EFP to an EFM formula.",
            "title": "efp2efms"
        },
        {
            "location": "/docs/utils/",
            "text": "Particle Tools\n\n\nTools to compute particle kinematic quantities from four-vectors,\nsuch as transverse momentum $p_T$, rapidity $y$, and azimuthal angle\n$\\phi$. Also includes functions for converting between Euclidean \nfour-momenta and $(p_T,y,\\phi,[m])$.\n\n\n\n\nflat_metric\n\n\nenergyflow.flat_metric(dim)\n\n\n\n\nThe Minkowski metric in \ndim\n spacetime dimensions in the mostly-minus convention.\n\n\nArguments\n\n\n\n\ndim\n : \nint\n\n\nThe number of spacetime dimensions (thought to be four in our universe).\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nA \ndim\n-length, one-dimensional (not matrix) array equal to \n[+1, -1, ..., -1]\n\n\n\n\n\n\n\n\n\n\np4s_from_ptyphims\n\n\nenergyflow.p4s_from_ptyphims(ptyphim)\n\n\n\n\nCalculate Euclidean four-vectors from transverse momentum, rapidity, azimuthal angle,\nand mass per input.\n\n\nArguments\n\n\n\n\nptyphims\n : \nnumpy.ndarray\n or \nlist\n\n\nAn array with shape \n(M, 4)\n of \n[pT, y, phi, m]\n for each particle. A single \nparticle is also accepted.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn event as an \n(M, 4)\n array of four-vectors \n[E, px, py, pz]\n for each particle.\nIf a single particle was given as input, a single four-vector will be returned.\n\n\n\n\n\n\n\n\n\n\np4s_from_ptyphis\n\n\nenergyflow.p4s_from_ptyphis(ptyphis)\n\n\n\n\nCalculate Euclidean four-vectors from transverse momentum, rapidity, and azimuthal angle.\nParticles are taken to be massless.\n\n\nArguments\n\n\n\n\nptyphims\n : \nnumpy.ndarray\n or \nlist\n\n\nAn array with shape \n(M, 3)\n of \n[pT, y, phi]\n for each particle. A single \nparticle is also accepted.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn event as an \n(M, 4)\n array of four-vectors \n[E, px, py, pz]\n for each particle.\nIf a single particle was given as input, a single four-vector will be returned.\n\n\n\n\n\n\n\n\n\n\npts_from_p4s\n\n\nenergyflow.pts_from_p4s(p4s)\n\n\n\n\nCalculate the transverse momenta of a collection of four-vectors\n\n\nArguments\n\n\n\n\np4s\n : \nnumpy.ndarray\n or \nlist\n\n\nAn event as an \n(M, 4)\n array of four-vectors \n[E, px, py, pz]\n for each particle.\nA single particle as a one-dimensional array or list is also accepted.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn \nM\n-length array consisting of the transverse momentum of each particle.\nIf a single particle was given as input, a single float is returned.\n\n\n\n\n\n\n\n\n\n\nys_from_p4s\n\n\nenergyflow.ys_from_p4s(p4s)\n\n\n\n\nCalculate the rapidities of a collection of four-vectors\n\n\nArguments\n\n\n\n\np4s\n : \nnumpy.ndarray\n or \nlist\n\n\nAn event as an \n(M, 4)\n array of four-vectors \n[E, px, py, pz]\n for each particle.\nA single particle as a one-dimensional array or list is also accepted.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn \nM\n-length array consisting of the rapidity of each particle.\nIf a single particle was given as input, a single float is returned.\n\n\n\n\n\n\n\n\n\n\nphi_fix\n\n\nenergyflow.phi_fix(phis, phi_ref, copy=False)\n\n\n\n\nA function to ensure that all phi values are within $\\pi$ of \nphi_ref\n. \nIt is assumed that all starting phi values are within $2\\pi$ of \nphi_ref\n.\n\n\nArguments\n\n\n\n\n\n\nphis\n : \nnumpy.ndarray\n or \nlist\n\n\n\n\nOne-dimensional array of phi values.\n\n\n\n\n\n\n\n\nphi_ref\n : \nfloat\n\n\n\n\nA reference value used so that all phis will be within $\\pm\\pi$ of this value.\n\n\n\n\n\n\n\n\ncopy\n : \nbool\n\n\n\n\nDetermines if \nphis\n are copied or not. If \nFalse\n then \nphis\n may be \nmodified in place.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn array of the fixed phi values.\n\n\n\n\n\n\n\n\n\n\nphis_from_p4s\n\n\nenergyflow.phis_from_p4s(p4s, phi_ref=None)\n\n\n\n\nCalculate the azimuthal angles of a collection of four-vectors. If \nphi_ref\n is \nnot \nNone\n, then \nphi_fix\n is called using this value. Otherwise, \nthe angles are chosen to be in the inverval $[0,2\\pi]$.\n\n\nArguments\n\n\n\n\n\n\np4s\n : \nnumpy.ndarray\n or \nlist\n\n\n\n\nAn event as an \n(M, 4)\n array of four-vectors \n[E, px, py, pz]\n for each particle.\nA single particle as a one-dimensional array or list is also accepted.\n\n\n\n\n\n\n\n\nphi_ref\n : \nfloat\n\n\n\n\nSee \n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n or \nlist\n\n\nAn \nM\n-length array consisting of the azimuthal angle of each particle.\nIf a single particle was given as input, a single float is returned.\n\n\n\n\n\n\n\n\n\n\nms_from_p4s\n\n\nenergyflow.ms_from_p4s(p4s)\n\n\n\n\nCalculate the masses of a collection of four-vectors.\n\n\nArguments\n\n\n\n\np4s\n : \nnumpy.ndarray\n or \nlist\n\n\nAn event as an \n(M, 4)\n array of four-vectors \n[E, px, py, pz]\n for each particle.\nA single particle as a one-dimensional array or list is also accepted.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn \nM\n-length array consisting of the mass of each particle. If a single \nparticle was given as input, a single float is returned.\n\n\n\n\n\n\n\n\n\n\nptyphims_from_p4s\n\n\nenergyflow.ptyphims_from_p4s(p4s, phi_ref=None, keep_shape=True)\n\n\n\n\nCompute the $(p_T,y,\\phi,m)$ representation of a four-vector for each Euclidean\nfour-vector given as input. All-zero four-vectors are removed unless \nkeep_shape\n \nis \nTrue\n.\n\n\nArguments\n\n\n\n\n\n\np4s\n : \nnumpy.ndarray\n or \nlist\n\n\n\n\nAn event as an \n(M, 4)\n array of four-vectors \n[E, px, py, pz]\n for each particle.\nA single particle as a one-dimensional array or list is also accepted.\n\n\n\n\n\n\n\n\nphi_ref\n : \nfloat\n\n\n\n\nA reference value used so that all phis will be within $\\pm\\pi$ of thie value.\n\n\n\n\n\n\n\n\nkeep_shape\n : \nbool\n\n\n\n\nFlag to determine if all-zero four-vectors will be retained. This is useful for\nkeeping the shape of an array.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn array of size \n(M, 4)\n consisting of the transverse momentum, rapidity,\nazimuthal angle, and mass of each particle. If a single particle was given as \ninput, a one-dimensional array is returned.\n\n\n\n\n\n\n\n\n\n\nTest Event Generation\n\n\nFunctions to generate random sets of four-vectors. Includes an implementation\nof the \nRAMBO\n algorithm for\nsampling uniform M-body massless phase space. Also includes other functions for\nvarious random, non-center of momentum, and non-uniform sampling.\n\n\n\n\ngen_massless_phase_space\n\n\nenergyflow.gen_massless_phase_space(nevents, nparticles, energy=1)\n\n\n\n\nImplementation of the \nRAMBO\n algorithm\nfor uniformly sampling massless M-body phase space for any center of mass energies.\n\n\nArguments\n\n\n\n\n\n\nnevents\n : \nint\n\n\n\n\nNumber of events to generate.\n\n\n\n\n\n\n\n\nnparticles\n : \nint\n\n\n\n\nNumber of particles in each event.\n\n\n\n\n\n\n\n\nenergy\n : \nfloat\n\n\n\n\nTotal center of mass energy of each event.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn (\nnevents\n, \nnparticles\n, 4) array of events, each with \nnparticles\n massless\nparticles and center of mass energy equal to \nenergy\n.\n\n\n\n\n\n\n\n\n\n\ngen_random_events\n\n\nenergyflow.gen_random_events(nevents, nparticles, dim=4, mass=0)\n\n\n\n\nGenerate random events with a given number of particles of a given mass\nin a given spacetime dimension. The energy-momentum vectors have spatial\ncomponents drawn randomly from [-1,+1]. These events are not guaranteed\nto uniformly sample phase space.\n\n\nArguments\n\n\n\n\n\n\nnevents\n : \nint\n\n\n\n\nNumber of events to generate.\n\n\n\n\n\n\n\n\nnparticles\n : \nint\n\n\n\n\nNumber of particles in each event.\n\n\n\n\n\n\n\n\ndim\n : \nint\n\n\n\n\nNumber of spacetime dimensions.\n\n\n\n\n\n\n\n\nmass\n : \nfloat\n\n\n\n\nMass of the particles to generate.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn (\nnevents\n, \nnparticles\n, \ndim\n) array of events, each with \nnparticles\n particles\nwith mass given by \nmass\n.\n\n\n\n\n\n\n\n\n\n\ngen_random_events_massless_com\n\n\nenergyflow.gen_random_events_massless_com(nevents, nparticles, dim=4)\n\n\n\n\nGenerate random events with a given number of massless particles\nin a given spacetime dimension. The total energy and momentum are made to sum to zero\nby making about half of the particles incoming. These events are not guaranteed\nto uniformly sample phase space.\n\n\nArguments\n\n\n\n\n\n\nnevents\n : \nint\n\n\n\n\nNumber of events to generate.\n\n\n\n\n\n\n\n\nnparticles\n : \nint\n\n\n\n\nNumber of particles in each event.\n\n\n\n\n\n\n\n\ndim\n : \nint\n\n\n\n\nNumber of spacetime dimensions.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn (\nnevents\n, \nnparticles\n, \ndim\n) array of events, each with \nnparticles\n massless\nparticles whose total energy and momentum are all zero.\n\n\n\n\n\n\n\n\n\n\nmass2\n\n\nenergyflow.mass2(events)\n\n\n\n\nCompute the squared masses of every particle in events with any-dimensional energy-momentum vectors.\n\n\nArguments\n\n\n\n\nevents\n : \nnumpy.ndarray\n\n\nEvents as an (\nnevents\n, \nM\n, \ndim\n) array of dim-vectors \n[p0, p1, ..., pdim-1]\n for each particle.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\nnumpy.ndarray\n\n\nAn (\nnevents\n, \nM\n) array of calculated particle masses.",
            "title": "Utils"
        },
        {
            "location": "/docs/utils/#particle-tools",
            "text": "Tools to compute particle kinematic quantities from four-vectors,\nsuch as transverse momentum $p_T$, rapidity $y$, and azimuthal angle\n$\\phi$. Also includes functions for converting between Euclidean \nfour-momenta and $(p_T,y,\\phi,[m])$.",
            "title": "Particle Tools"
        },
        {
            "location": "/docs/utils/#flat_metric",
            "text": "energyflow.flat_metric(dim)  The Minkowski metric in  dim  spacetime dimensions in the mostly-minus convention.  Arguments   dim  :  int  The number of spacetime dimensions (thought to be four in our universe).     Returns   numpy.ndarray  A  dim -length, one-dimensional (not matrix) array equal to  [+1, -1, ..., -1]",
            "title": "flat_metric"
        },
        {
            "location": "/docs/utils/#p4s_from_ptyphims",
            "text": "energyflow.p4s_from_ptyphims(ptyphim)  Calculate Euclidean four-vectors from transverse momentum, rapidity, azimuthal angle,\nand mass per input.  Arguments   ptyphims  :  numpy.ndarray  or  list  An array with shape  (M, 4)  of  [pT, y, phi, m]  for each particle. A single \nparticle is also accepted.     Returns   numpy.ndarray  An event as an  (M, 4)  array of four-vectors  [E, px, py, pz]  for each particle.\nIf a single particle was given as input, a single four-vector will be returned.",
            "title": "p4s_from_ptyphims"
        },
        {
            "location": "/docs/utils/#p4s_from_ptyphis",
            "text": "energyflow.p4s_from_ptyphis(ptyphis)  Calculate Euclidean four-vectors from transverse momentum, rapidity, and azimuthal angle.\nParticles are taken to be massless.  Arguments   ptyphims  :  numpy.ndarray  or  list  An array with shape  (M, 3)  of  [pT, y, phi]  for each particle. A single \nparticle is also accepted.     Returns   numpy.ndarray  An event as an  (M, 4)  array of four-vectors  [E, px, py, pz]  for each particle.\nIf a single particle was given as input, a single four-vector will be returned.",
            "title": "p4s_from_ptyphis"
        },
        {
            "location": "/docs/utils/#pts_from_p4s",
            "text": "energyflow.pts_from_p4s(p4s)  Calculate the transverse momenta of a collection of four-vectors  Arguments   p4s  :  numpy.ndarray  or  list  An event as an  (M, 4)  array of four-vectors  [E, px, py, pz]  for each particle.\nA single particle as a one-dimensional array or list is also accepted.     Returns   numpy.ndarray  An  M -length array consisting of the transverse momentum of each particle.\nIf a single particle was given as input, a single float is returned.",
            "title": "pts_from_p4s"
        },
        {
            "location": "/docs/utils/#ys_from_p4s",
            "text": "energyflow.ys_from_p4s(p4s)  Calculate the rapidities of a collection of four-vectors  Arguments   p4s  :  numpy.ndarray  or  list  An event as an  (M, 4)  array of four-vectors  [E, px, py, pz]  for each particle.\nA single particle as a one-dimensional array or list is also accepted.     Returns   numpy.ndarray  An  M -length array consisting of the rapidity of each particle.\nIf a single particle was given as input, a single float is returned.",
            "title": "ys_from_p4s"
        },
        {
            "location": "/docs/utils/#phi_fix",
            "text": "energyflow.phi_fix(phis, phi_ref, copy=False)  A function to ensure that all phi values are within $\\pi$ of  phi_ref . \nIt is assumed that all starting phi values are within $2\\pi$ of  phi_ref .  Arguments    phis  :  numpy.ndarray  or  list   One-dimensional array of phi values.     phi_ref  :  float   A reference value used so that all phis will be within $\\pm\\pi$ of this value.     copy  :  bool   Determines if  phis  are copied or not. If  False  then  phis  may be \nmodified in place.     Returns   numpy.ndarray  An array of the fixed phi values.",
            "title": "phi_fix"
        },
        {
            "location": "/docs/utils/#phis_from_p4s",
            "text": "energyflow.phis_from_p4s(p4s, phi_ref=None)  Calculate the azimuthal angles of a collection of four-vectors. If  phi_ref  is \nnot  None , then  phi_fix  is called using this value. Otherwise, \nthe angles are chosen to be in the inverval $[0,2\\pi]$.  Arguments    p4s  :  numpy.ndarray  or  list   An event as an  (M, 4)  array of four-vectors  [E, px, py, pz]  for each particle.\nA single particle as a one-dimensional array or list is also accepted.     phi_ref  :  float   See      Returns   numpy.ndarray  or  list  An  M -length array consisting of the azimuthal angle of each particle.\nIf a single particle was given as input, a single float is returned.",
            "title": "phis_from_p4s"
        },
        {
            "location": "/docs/utils/#ms_from_p4s",
            "text": "energyflow.ms_from_p4s(p4s)  Calculate the masses of a collection of four-vectors.  Arguments   p4s  :  numpy.ndarray  or  list  An event as an  (M, 4)  array of four-vectors  [E, px, py, pz]  for each particle.\nA single particle as a one-dimensional array or list is also accepted.     Returns   numpy.ndarray  An  M -length array consisting of the mass of each particle. If a single \nparticle was given as input, a single float is returned.",
            "title": "ms_from_p4s"
        },
        {
            "location": "/docs/utils/#ptyphims_from_p4s",
            "text": "energyflow.ptyphims_from_p4s(p4s, phi_ref=None, keep_shape=True)  Compute the $(p_T,y,\\phi,m)$ representation of a four-vector for each Euclidean\nfour-vector given as input. All-zero four-vectors are removed unless  keep_shape  \nis  True .  Arguments    p4s  :  numpy.ndarray  or  list   An event as an  (M, 4)  array of four-vectors  [E, px, py, pz]  for each particle.\nA single particle as a one-dimensional array or list is also accepted.     phi_ref  :  float   A reference value used so that all phis will be within $\\pm\\pi$ of thie value.     keep_shape  :  bool   Flag to determine if all-zero four-vectors will be retained. This is useful for\nkeeping the shape of an array.     Returns   numpy.ndarray  An array of size  (M, 4)  consisting of the transverse momentum, rapidity,\nazimuthal angle, and mass of each particle. If a single particle was given as \ninput, a one-dimensional array is returned.",
            "title": "ptyphims_from_p4s"
        },
        {
            "location": "/docs/utils/#test-event-generation",
            "text": "Functions to generate random sets of four-vectors. Includes an implementation\nof the  RAMBO  algorithm for\nsampling uniform M-body massless phase space. Also includes other functions for\nvarious random, non-center of momentum, and non-uniform sampling.",
            "title": "Test Event Generation"
        },
        {
            "location": "/docs/utils/#gen_massless_phase_space",
            "text": "energyflow.gen_massless_phase_space(nevents, nparticles, energy=1)  Implementation of the  RAMBO  algorithm\nfor uniformly sampling massless M-body phase space for any center of mass energies.  Arguments    nevents  :  int   Number of events to generate.     nparticles  :  int   Number of particles in each event.     energy  :  float   Total center of mass energy of each event.     Returns   numpy.ndarray  An ( nevents ,  nparticles , 4) array of events, each with  nparticles  massless\nparticles and center of mass energy equal to  energy .",
            "title": "gen_massless_phase_space"
        },
        {
            "location": "/docs/utils/#gen_random_events",
            "text": "energyflow.gen_random_events(nevents, nparticles, dim=4, mass=0)  Generate random events with a given number of particles of a given mass\nin a given spacetime dimension. The energy-momentum vectors have spatial\ncomponents drawn randomly from [-1,+1]. These events are not guaranteed\nto uniformly sample phase space.  Arguments    nevents  :  int   Number of events to generate.     nparticles  :  int   Number of particles in each event.     dim  :  int   Number of spacetime dimensions.     mass  :  float   Mass of the particles to generate.     Returns   numpy.ndarray  An ( nevents ,  nparticles ,  dim ) array of events, each with  nparticles  particles\nwith mass given by  mass .",
            "title": "gen_random_events"
        },
        {
            "location": "/docs/utils/#gen_random_events_massless_com",
            "text": "energyflow.gen_random_events_massless_com(nevents, nparticles, dim=4)  Generate random events with a given number of massless particles\nin a given spacetime dimension. The total energy and momentum are made to sum to zero\nby making about half of the particles incoming. These events are not guaranteed\nto uniformly sample phase space.  Arguments    nevents  :  int   Number of events to generate.     nparticles  :  int   Number of particles in each event.     dim  :  int   Number of spacetime dimensions.     Returns   numpy.ndarray  An ( nevents ,  nparticles ,  dim ) array of events, each with  nparticles  massless\nparticles whose total energy and momentum are all zero.",
            "title": "gen_random_events_massless_com"
        },
        {
            "location": "/docs/utils/#mass2",
            "text": "energyflow.mass2(events)  Compute the squared masses of every particle in events with any-dimensional energy-momentum vectors.  Arguments   events  :  numpy.ndarray  Events as an ( nevents ,  M ,  dim ) array of dim-vectors  [p0, p1, ..., pdim-1]  for each particle.     Returns   numpy.ndarray  An ( nevents ,  M ) array of calculated particle masses.",
            "title": "mass2"
        }
    ]
}