{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to EnergyFlow\n\n\nEnergyFlow is a Python package for computing Energy Flow Polynomials, a collection of jet substructure observables which form a complete, linear basis of IRC-safe observables.\n\n\nNote\n: We are currently in beta. Fully tested code and site coming soon!\n\n\nReferences\n\n\n[1] P.T. Komiske, E.M. Metodiev, J. Thaler, \"Energy Flow Polynomials: A complete linear basis for jet substructure.\" \nTo appear soon.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-energyflow",
            "text": "EnergyFlow is a Python package for computing Energy Flow Polynomials, a collection of jet substructure observables which form a complete, linear basis of IRC-safe observables.  Note : We are currently in beta. Fully tested code and site coming soon!",
            "title": "Welcome to EnergyFlow"
        },
        {
            "location": "/#references",
            "text": "[1] P.T. Komiske, E.M. Metodiev, J. Thaler, \"Energy Flow Polynomials: A complete linear basis for jet substructure.\"  To appear soon.",
            "title": "References"
        },
        {
            "location": "/intro/efpintro/",
            "text": "The Energy Flow Basis\n\n\nEnergy flow polynomials (EFPs) are a set of observables, indexed by non-isomorphic multigraphs, which linearly span the space of infrared and collinear safe (IRC-safe) observables.\n\n\nAn EFP index by a multigraph $G$ takes the following form:\n\n \\text{EFP}_G =  \\sum_{i_1=1}^M \\cdots \\sum_{i_N = 1}^M z_{i_1}\\cdots z_{i_N} \\prod_{(k,\\ell)\\in G} \\theta_{i_k i_\\ell}\n\nwhere $z_i$ is a measure of the energy of particle $i$ and $\\theta_{ij}$ is a measure of the angular separation between particles $i$ and $j$. The specific choices for energy and angular measure depend on the collider context and are discussed at length in the \nMeasures\n section.",
            "title": "Energy Flow Polynomials"
        },
        {
            "location": "/intro/efpintro/#the-energy-flow-basis",
            "text": "Energy flow polynomials (EFPs) are a set of observables, indexed by non-isomorphic multigraphs, which linearly span the space of infrared and collinear safe (IRC-safe) observables.  An EFP index by a multigraph $G$ takes the following form:  \\text{EFP}_G =  \\sum_{i_1=1}^M \\cdots \\sum_{i_N = 1}^M z_{i_1}\\cdots z_{i_N} \\prod_{(k,\\ell)\\in G} \\theta_{i_k i_\\ell} \nwhere $z_i$ is a measure of the energy of particle $i$ and $\\theta_{ij}$ is a measure of the angular separation between particles $i$ and $j$. The specific choices for energy and angular measure depend on the collider context and are discussed at length in the  Measures  section.",
            "title": "The Energy Flow Basis"
        },
        {
            "location": "/intro/measures/",
            "text": "Energy and Angular Measures\n\n\nThe appropriate notions of energy and angle depend on the collider context. Typically, one wants to work with observables that respect the appropriate Lorentz subgroup for the collision type of interest. EnergyFlow is capable of handling two broad classes of measures: $e^+e^-$ and hadronic, which are selected using the \nmeasure\n keyword argument (the defaul is \n'hadr'\n, described below).\n\n\nFor substructure applications, it is often convenient to normalize the energies so that $\\sum_iz_i=1$. The \nnormed\n keyword argument is provided to control normalization of the energies (the default is \nTrue\n).\n\n\nEach measure comes with a parameter $\\beta>0$ which controls the relative weighting between small and larger angles. This can be set using the \nbeta\n keyword argument (the default is \n1\n.\n\n\nBeyond the measures implemented here, the user can implement their own custom measure by passing ${z_i}$ and ${\\theta_{ij}}$ in directly to the EFP classes.\n\n\nHadronic Collisions\n\n\nFor hadronic collisions, observables are typically desired to be invariant under boosts along the beam direction and rotations about the beam direction. Thus, particle transverse momentum $p_T$ and rapidity-azimuth coordinates $(y,\\phi)$ are often used.\n\n\nThere are two hadronic measures implemented in EnergyFlow: \n'hadr'\n (the default) and \n'hadr-dot'\n. These are listed explicitly below in the normalized-energy version (the unnormalized version follows by removing the denominator).\n\n\n'hadr'\n:\n\nz_i=\\frac{p_{T,i}}{\\displaystyle\\sum_{k=1}^Mp_{T,k}},\\quad\\quad \\theta_{ij}=(\\Delta y_{ij}^2 + \\Delta\\phi_{ij}^2)^{\\beta/2}.\n\n\n\n\n'hadr-dot'\n:\n\nz_i=\\frac{p_{T,i}}{\\displaystyle\\sum_{k=1}^Mp_{T,k}},\\quad\\quad \\theta_{ij}=\\left(\\frac{2p^\\mu_ip_{j\\mu}}{p_{T,i}p_{T,j}}\\right)^{\\beta/2}.\n\n\n\n\ne+e-\n Collisions\n\n\nFor $e^+e^-$ collisions, observables are typically desired to be invariant under the full group of reotations about the interaction point. Since the center of momentum energy is known, the particle energy $E$ is typically used. For the angular measure, pairwise Lorentz contractions of the normalized particle four-momenta are used.\n\n\nThere is one $e^+e^-$ measure implemented in the EnergyFlow framework.\n\n\n'ee'\n:\n\nz_i = \\frac{E_{i}}{\\displaystyle\\sum_{k=1} E_{k}},\n\\quad\\quad \\theta_{ij} = \\left(\\frac{2p_i^\\mu p_{j \\mu}}{E_i E_j}\\right)^{\\beta/2}.",
            "title": "Measures"
        },
        {
            "location": "/intro/measures/#energy-and-angular-measures",
            "text": "The appropriate notions of energy and angle depend on the collider context. Typically, one wants to work with observables that respect the appropriate Lorentz subgroup for the collision type of interest. EnergyFlow is capable of handling two broad classes of measures: $e^+e^-$ and hadronic, which are selected using the  measure  keyword argument (the defaul is  'hadr' , described below).  For substructure applications, it is often convenient to normalize the energies so that $\\sum_iz_i=1$. The  normed  keyword argument is provided to control normalization of the energies (the default is  True ).  Each measure comes with a parameter $\\beta>0$ which controls the relative weighting between small and larger angles. This can be set using the  beta  keyword argument (the default is  1 .  Beyond the measures implemented here, the user can implement their own custom measure by passing ${z_i}$ and ${\\theta_{ij}}$ in directly to the EFP classes.",
            "title": "Energy and Angular Measures"
        },
        {
            "location": "/intro/measures/#hadronic-collisions",
            "text": "For hadronic collisions, observables are typically desired to be invariant under boosts along the beam direction and rotations about the beam direction. Thus, particle transverse momentum $p_T$ and rapidity-azimuth coordinates $(y,\\phi)$ are often used.  There are two hadronic measures implemented in EnergyFlow:  'hadr'  (the default) and  'hadr-dot' . These are listed explicitly below in the normalized-energy version (the unnormalized version follows by removing the denominator).  'hadr' : z_i=\\frac{p_{T,i}}{\\displaystyle\\sum_{k=1}^Mp_{T,k}},\\quad\\quad \\theta_{ij}=(\\Delta y_{ij}^2 + \\Delta\\phi_{ij}^2)^{\\beta/2}.   'hadr-dot' : z_i=\\frac{p_{T,i}}{\\displaystyle\\sum_{k=1}^Mp_{T,k}},\\quad\\quad \\theta_{ij}=\\left(\\frac{2p^\\mu_ip_{j\\mu}}{p_{T,i}p_{T,j}}\\right)^{\\beta/2}.",
            "title": "Hadronic Collisions"
        },
        {
            "location": "/intro/measures/#ee-collisions",
            "text": "For $e^+e^-$ collisions, observables are typically desired to be invariant under the full group of reotations about the interaction point. Since the center of momentum energy is known, the particle energy $E$ is typically used. For the angular measure, pairwise Lorentz contractions of the normalized particle four-momenta are used.  There is one $e^+e^-$ measure implemented in the EnergyFlow framework.  'ee' : z_i = \\frac{E_{i}}{\\displaystyle\\sum_{k=1} E_{k}},\n\\quad\\quad \\theta_{ij} = \\left(\\frac{2p_i^\\mu p_{j \\mu}}{E_i E_j}\\right)^{\\beta/2}.",
            "title": "e+e- Collisions"
        },
        {
            "location": "/installation/",
            "text": "The EnergyFlow package is (currently) written in pure Python and depends only on NumPy, the fundamental package for scientific computing with Python, and six, which is a lightweight module to patch some inconvenient differences between Python 2 and Python3.\n\n\nThe EnergyFlow package is designed to work with Python 2.7, 3.4, 3.5, 3.6. These can be installed from \nhere\n. The latest stable version of Python 3 is highly recommended.\n\n\nInstall with \npip\n (recommended)\n\n\nTo install from PyPI using \npip\n, make sure you have one of the supported versions of Python installed and that \npip\n is available in the system path. Simply execute \npip install energyflow\n and EnergyFlow will be installed in your default location for Python packages.\n\n\nBleeding edge install\n\n\nEnergyFlow is \nhosted on GitHub\n and can be installed by cloning the repository and running \npython setup.py install\n. This is not recommended compared to installation with \npip\n because the released versions are more thoroughly tested.\n\n\niGraph\n\n\nDevelopment NumPy\n\n\nSince EnergyFlow relies on \nnumpy.einsum\n to do most of the computational heavy lifting, newer versions of NumPy may provide changes/speedups in performance if \neinsum\n changes. At the present time, the master branch of the NumPy repo contains some significant changes to \neinsum\n compared to NumPy \n1.1.13\n. Currently, we recommend using the latest stable version of NumPy, but this may change in the future.",
            "title": "Installation"
        },
        {
            "location": "/installation/#install-with-pip-recommended",
            "text": "To install from PyPI using  pip , make sure you have one of the supported versions of Python installed and that  pip  is available in the system path. Simply execute  pip install energyflow  and EnergyFlow will be installed in your default location for Python packages.",
            "title": "Install with pip (recommended)"
        },
        {
            "location": "/installation/#bleeding-edge-install",
            "text": "EnergyFlow is  hosted on GitHub  and can be installed by cloning the repository and running  python setup.py install . This is not recommended compared to installation with  pip  because the released versions are more thoroughly tested.",
            "title": "Bleeding edge install"
        },
        {
            "location": "/installation/#igraph",
            "text": "",
            "title": "iGraph"
        },
        {
            "location": "/installation/#development-numpy",
            "text": "Since EnergyFlow relies on  numpy.einsum  to do most of the computational heavy lifting, newer versions of NumPy may provide changes/speedups in performance if  einsum  changes. At the present time, the master branch of the NumPy repo contains some significant changes to  einsum  compared to NumPy  1.1.13 . Currently, we recommend using the latest stable version of NumPy, but this may change in the future.",
            "title": "Development NumPy"
        },
        {
            "location": "/tutorial/",
            "text": "",
            "title": "Tutorial"
        },
        {
            "location": "/faq/",
            "text": "Frequently Asked EnergyFlow Questions\n\n\n\n\nHow do I cite the EnergyFlow package?\n\n\nWhy Python instead of C++?\n\n\nCan I contribute to the code?\n\n\nHow do I report an issue or a bug?\n\n\nWhere can I get graph image files?\n\n\n\n\n\n\nHow do I cite the EnergyFlow package?\n\n\nPlease cite the relevant Energy Flow papers if they or this package helps your research. Here are the BibTeX entries to use:\n\n\n@article{Komiske:temp,\n      author         = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\",\n      title          = \"{Energy Flow Polynomials: A complete linear basis for jet substructure}\",\n      archivePrefix  = \"arXiv\",\n      primaryClass   = \"hep-ph\",\n      reportNumber   = \"MIT-CTP-4965\",\n }\n\n\n\n\nWhy Python instead of C++?\n\n\nComputing the energy flow polynomials requires a function such as NumPy's \neinsum\n that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use.\n\n\nNumPy\n is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the energy flow polynomials. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and features such as SSE instructions.\n\n\nCan I contribute to the code?\n\n\nAll of our code is open source and hosted on \nGitHub\n. We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository.\n\n\nHow do I report an issue?\n\n\nPlease let us know of any issues you encounter as soon as possible by creating an \nIssue\n on the EnergyFlow GitHub repository.\n\n\nWhere can I get graph image files?\n\n\nImage files for all connected multigraphs with up to 7 edges in the energy flow polynomial style are available as pdf files \nhere\n. You are free to use them with the proper attribution.",
            "title": "FAQ"
        },
        {
            "location": "/faq/#frequently-asked-energyflow-questions",
            "text": "How do I cite the EnergyFlow package?  Why Python instead of C++?  Can I contribute to the code?  How do I report an issue or a bug?  Where can I get graph image files?",
            "title": "Frequently Asked EnergyFlow Questions"
        },
        {
            "location": "/faq/#how-do-i-cite-the-energyflow-package",
            "text": "Please cite the relevant Energy Flow papers if they or this package helps your research. Here are the BibTeX entries to use:  @article{Komiske:temp,\n      author         = \"Komiske, Patrick T. and Metodiev, Eric M. and Thaler, Jesse\",\n      title          = \"{Energy Flow Polynomials: A complete linear basis for jet substructure}\",\n      archivePrefix  = \"arXiv\",\n      primaryClass   = \"hep-ph\",\n      reportNumber   = \"MIT-CTP-4965\",\n }",
            "title": "How do I cite the EnergyFlow package?"
        },
        {
            "location": "/faq/#why-python-instead-of-c",
            "text": "Computing the energy flow polynomials requires a function such as NumPy's  einsum  that can efficiently evaluate arbitrary tensor contractions. To write such a function from scratch in C++ is difficult, and there is no obvious library in C++ to use.  NumPy  is a highly-optimized Python library written in C that provides all of the tools required to efficiently compute the energy flow polynomials. Libraries like NumPy take advantage of optimizations that the physicist-programmer typically does not, such as architecture-optimized libraries like BLAS or LAPACK and features such as SSE instructions.",
            "title": "Why Python instead of C++?"
        },
        {
            "location": "/faq/#can-i-contribute-to-the-code",
            "text": "All of our code is open source and hosted on  GitHub . We welcome additional contributors, and if you are interested in getting involved please contact us directly. Contact information is included in the relevant Energy Flow papers and our GitHub repository.",
            "title": "Can I contribute to the code?"
        },
        {
            "location": "/faq/#how-do-i-report-an-issue",
            "text": "Please let us know of any issues you encounter as soon as possible by creating an  Issue  on the EnergyFlow GitHub repository.",
            "title": "How do I report an issue?"
        },
        {
            "location": "/faq/#where-can-i-get-graph-image-files",
            "text": "Image files for all connected multigraphs with up to 7 edges in the energy flow polynomial style are available as pdf files  here . You are free to use them with the proper attribution.",
            "title": "Where can I get graph image files?"
        },
        {
            "location": "/docs/multigraphs/",
            "text": "Note that unless igraph is importable, the functionality of this module will not be available. EnergyFlow is still usable with the provided default file of precomputed multigraphs.\n\n\nGenerator\n\n\nGenerator(dmax, nmax=None, emax=None, cmax=None, verbose=False, ve_alg='numpy', np_optimize='greedy')\n\n\n\n\nArguments\n\n\n\n\ndmax\n: Positive integer, the maximum degree (number of edges).\n\n\nnmax\n: Positive integer, the maximum number of vertices (\nNone\n sets \nnmax=dmax+1\n).\n\n\nemax\n: Positive integer, maximum number of edges of the underlying simples graphs (\nNone\n sets \nemax=dmax\n).\n\n\ncmax\n: Positive integer, maximum ve complexity (\nNone\n sets  \ncmax=nmax\n).\n\n\nverbose\n: Boolean, controls printing output.\n\n\nve_alg\n: String, controls which variable elimination algorithm is used, either \nnumpy\n or \nef\n. Leave as \nnumpy\n unless you know what you're doing.\n\n\nnp_optimize\n: String, when \nve_alg='numpy'\n this is the \noptimize\n keyword of \nnumpy.einsum_path\n.",
            "title": "Multigraphs"
        },
        {
            "location": "/docs/multigraphs/#generator",
            "text": "Generator(dmax, nmax=None, emax=None, cmax=None, verbose=False, ve_alg='numpy', np_optimize='greedy')  Arguments   dmax : Positive integer, the maximum degree (number of edges).  nmax : Positive integer, the maximum number of vertices ( None  sets  nmax=dmax+1 ).  emax : Positive integer, maximum number of edges of the underlying simples graphs ( None  sets  emax=dmax ).  cmax : Positive integer, maximum ve complexity ( None  sets   cmax=nmax ).  verbose : Boolean, controls printing output.  ve_alg : String, controls which variable elimination algorithm is used, either  numpy  or  ef . Leave as  numpy  unless you know what you're doing.  np_optimize : String, when  ve_alg='numpy'  this is the  optimize  keyword of  numpy.einsum_path .",
            "title": "Generator"
        },
        {
            "location": "/docs/polynomials/",
            "text": "These are the classes that actually compute EFPs. If you plan on studying single graphs, \nEFP\n would typically be used. For studying EFPs in large collections, use \nEFPSet\n for greater efficiency and simplicity.\n\n\nEFP\n\n\nEFP(edges, measure='hadr', beta=1.0, normed=True, check_type=True, ve_alg='numpy', np_optimize='greedy')\n\n\n\n\nA class for a storing and computing a single EFP.\n\n\nArguments\n\n\n\n\nedges\n: List, edges of the EFP graph specified by tuple-pairs of vertices.\n\n\nmeasure\n: String, see \nMeasures\n for options (defaults to \n'hadr'\n).\n\n\nbeta\n: Float, a value greater than zero (defaults to \n1.0\n). \n\n\nnormed\n: Boolean, controls energy normalization (defaults to \nTrue\n).\n\n\ncheck_type\n: Boolean, whether to check the type of the input or use the first input type (defaults to \nTrue\n).\n\n\nve_alg\n: String, controls which variable elimination algorithm is used, either \nnumpy\n or \nef\n. Leave as \nnumpy\n unless you know what you're doing.\n\n\nnp_optimize\n: String, when \nve_alg='numpy'\n this is the \noptimize\n keyword of \nnumpy.einsum_path\n \n\n\n\n\nEFPSet\n\n\nEFP(*args, filename=None, measure='hadr', beta=1.0, normed=True, check_type=True, verbose=False)\n\n\n\n\nA class for holding collections of EFPs.\n\n\nArguments\n\n\n\n\n*args\n: An arbitrary number of selection criteria. See \nsel\n.\n\n\nfilename\n: String, name of a file saved by a custom \nGenerator\n.\n\n\nmeasure\n: String, see \nMeasures\n for options (defaults to \n'hadr'\n).\n\n\nbeta\n: Float, a value greater than zero (defaults to \n1.0\n). \n\n\nnormed\n: Boolean, controls energy normalization (defaults to \nTrue\n).\n\n\ncheck_type\n: Boolean, whether to check the type of the input or use the first input type (defaults to \nTrue\n).\n\n\nverbose\n: Boolean, controls printing output.",
            "title": "Polynomials"
        },
        {
            "location": "/docs/polynomials/#efp",
            "text": "EFP(edges, measure='hadr', beta=1.0, normed=True, check_type=True, ve_alg='numpy', np_optimize='greedy')  A class for a storing and computing a single EFP.  Arguments   edges : List, edges of the EFP graph specified by tuple-pairs of vertices.  measure : String, see  Measures  for options (defaults to  'hadr' ).  beta : Float, a value greater than zero (defaults to  1.0 ).   normed : Boolean, controls energy normalization (defaults to  True ).  check_type : Boolean, whether to check the type of the input or use the first input type (defaults to  True ).  ve_alg : String, controls which variable elimination algorithm is used, either  numpy  or  ef . Leave as  numpy  unless you know what you're doing.  np_optimize : String, when  ve_alg='numpy'  this is the  optimize  keyword of  numpy.einsum_path",
            "title": "EFP"
        },
        {
            "location": "/docs/polynomials/#efpset",
            "text": "EFP(*args, filename=None, measure='hadr', beta=1.0, normed=True, check_type=True, verbose=False)  A class for holding collections of EFPs.  Arguments   *args : An arbitrary number of selection criteria. See  sel .  filename : String, name of a file saved by a custom  Generator .  measure : String, see  Measures  for options (defaults to  'hadr' ).  beta : Float, a value greater than zero (defaults to  1.0 ).   normed : Boolean, controls energy normalization (defaults to  True ).  check_type : Boolean, whether to check the type of the input or use the first input type (defaults to  True ).  verbose : Boolean, controls printing output.",
            "title": "EFPSet"
        }
    ]
}