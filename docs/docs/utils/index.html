<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Patrick T. Komiske III, Eric M. Metodiev">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Utils - EnergyFlow</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  <link href="../../css/eftheme.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Utils";
    var mkdocs_page_input_path = "docs/utils.md";
    var mkdocs_page_url = "/docs/utils/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-122962541-1', 'energyflow.network');
      ga('send', 'pageview');
  </script>
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../..">
            <div class="eflogo">
                <img src="../../img/eflogowhite.png"  class="eflogo-img"> EnergyFlow
            </div>
        </a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Getting Started</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../installation/">Installation</a>
                </li>
                <li class="">
                    
    <a class="" href="../../demos/">Demos</a>
                </li>
                <li class="">
                    
    <a class="" href="../../examples/">Examples</a>
                </li>
                <li class="">
                    
    <a class="" href="../../faqs/">FAQs</a>
                </li>
                <li class="">
                    
    <a class="" href="../../releases/">Release Notes</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Documentation</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../archs/">Architectures</a>
                </li>
                <li class="">
                    
    <a class="" href="../datasets/">Datasets</a>
                </li>
                <li class="">
                    
    <a class="" href="../emd/">EMD</a>
                </li>
                <li class="">
                    
    <a class="" href="../efps/">Energy Flow Polynomials</a>
                </li>
                <li class="">
                    
    <a class="" href="../measures/">Measures</a>
                </li>
                <li class="">
                    
    <a class="" href="../gen/">Multigraph Generation</a>
                </li>
                <li class="">
                    
    <a class="" href="../obs/">Observables</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Utils</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#particle-tools">Particle Tools</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#ptyphims_from_p4s">ptyphims_from_p4s</a></li>
        
            <li><a class="toctree-l4" href="#pts_from_p4s">pts_from_p4s</a></li>
        
            <li><a class="toctree-l4" href="#pt2s_from_p4s">pt2s_from_p4s</a></li>
        
            <li><a class="toctree-l4" href="#ys_from_p4s">ys_from_p4s</a></li>
        
            <li><a class="toctree-l4" href="#etas_from_p4s">etas_from_p4s</a></li>
        
            <li><a class="toctree-l4" href="#phis_from_p4s">phis_from_p4s</a></li>
        
            <li><a class="toctree-l4" href="#m2s_from_p4s">m2s_from_p4s</a></li>
        
            <li><a class="toctree-l4" href="#ms_from_p4s">ms_from_p4s</a></li>
        
            <li><a class="toctree-l4" href="#ms_from_ps">ms_from_ps</a></li>
        
            <li><a class="toctree-l4" href="#etas_from_pts_ys_ms">etas_from_pts_ys_ms</a></li>
        
            <li><a class="toctree-l4" href="#ys_from_pts_etas_ms">ys_from_pts_etas_ms</a></li>
        
            <li><a class="toctree-l4" href="#p4s_from_ptyphims">p4s_from_ptyphims</a></li>
        
            <li><a class="toctree-l4" href="#p4s_from_ptyphipids">p4s_from_ptyphipids</a></li>
        
            <li><a class="toctree-l4" href="#sum_ptyphims">sum_ptyphims</a></li>
        
            <li><a class="toctree-l4" href="#sum_ptyphipids">sum_ptyphipids</a></li>
        
            <li><a class="toctree-l4" href="#center_ptyphims">center_ptyphims</a></li>
        
            <li><a class="toctree-l4" href="#rotate_ptyphims">rotate_ptyphims</a></li>
        
            <li><a class="toctree-l4" href="#reflect_ptyphims">reflect_ptyphims</a></li>
        
            <li><a class="toctree-l4" href="#pids2ms">pids2ms</a></li>
        
            <li><a class="toctree-l4" href="#pids2chrgs">pids2chrgs</a></li>
        
            <li><a class="toctree-l4" href="#ischrgd">ischrgd</a></li>
        
            <li><a class="toctree-l4" href="#phi_fix">phi_fix</a></li>
        
            <li><a class="toctree-l4" href="#flat_metric">flat_metric</a></li>
        
        </ul>
    

    <li class="toctree-l3"><a href="#random-events">Random Events</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#gen_random_events">gen_random_events</a></li>
        
            <li><a class="toctree-l4" href="#gen_random_events_mcom">gen_random_events_mcom</a></li>
        
            <li><a class="toctree-l4" href="#gen_massless_phase_space">gen_massless_phase_space</a></li>
        
        </ul>
    

    <li class="toctree-l3"><a href="#data-tools">Data Tools</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#get_examples">get_examples</a></li>
        
            <li><a class="toctree-l4" href="#data_split">data_split</a></li>
        
            <li><a class="toctree-l4" href="#to_categorical">to_categorical</a></li>
        
            <li><a class="toctree-l4" href="#remap_pids">remap_pids</a></li>
        
        </ul>
    

    <li class="toctree-l3"><a href="#image-tools">Image Tools</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#pixelate">pixelate</a></li>
        
            <li><a class="toctree-l4" href="#standardize">standardize</a></li>
        
            <li><a class="toctree-l4" href="#zero_center">zero_center</a></li>
        
        </ul>
    

    <li class="toctree-l3"><a href="#fastjet-tools">FastJet Tools</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#pjs_from_ptyphims">pjs_from_ptyphims</a></li>
        
            <li><a class="toctree-l4" href="#cluster">cluster</a></li>
        
            <li><a class="toctree-l4" href="#softdrop">softdrop</a></li>
        
        </ul>
    

    </ul>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">EnergyFlow</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Documentation &raquo;</li>
        
      
    
    <li>Utils</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/pkomiske/EnergyFlow/edit/master/docs/docs/utils.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h3 id="particle-tools">Particle Tools</h3>
<p>Tools for dealing with particle momenta four-vectors. A four-vector can either
be in Cartesian coordinates, <code>[e,px,py,pz]</code> (energy, momentum in <code>x</code> direction,
momentum in <code>y</code> direction, momentum in <code>z</code> direction), or hadronic coordinates, 
<code>[pt,y,phi,m]</code> (transverse momentum, rapidity, azimuthal angle, mass), which
are related via:</p>
<p>
<script type="math/tex; mode=display">p_T=\sqrt{p_x^2+p_y^2},\quad y=\text{arctanh}\,\frac{p_z}{E},\quad 
\phi=\arctan_2\frac{p_y}{p_x},\quad m=\sqrt{E^2-p_x^2-p_y^2-p_z^2}</script>
</p>
<p>and inversely:</p>
<p>
<script type="math/tex; mode=display">E=\cosh y\sqrt{p_T^2+m^2},\quad p_x=p_T\cos\phi,\quad 
p_y=p_T\sin\phi,\quad p_z=\sinh y\sqrt{p_T^2+m^2}.</script>
</p>
<p>The pseudorapidity <code>eta</code> can be obtained from a Cartesian four-momentum as:</p>
<p>
<script type="math/tex; mode=display">\eta=\text{arctanh}\,\frac{p_z}{|\vec p|},\quad 
|\vec p|\equiv\sqrt{p_x^2+p_y^2+p_z^2},</script>
</p>
<p>and is related to the rapidity via</p>
<p>
<script type="math/tex; mode=display">\eta=\text{arcsinh}\left(\sinh y\,\left(1+m^2/p_T^2\right)^{1/2}\right),\quad 
y=\text{arcsinh}\left(\sinh \eta\,\left(1+m^2/p_T^2\right)^{-1/2}\right).</script>
</p>
<p>Note that the above formulas are numerically stable up to values of rapidity or
pseudorapidity of a few hundred, above which the formulas have numerical issues. 
In this case, a different but equivalent formulae are used that are numerically
stable in this region. In all cases, the $p_T\to0$ limit produces infinite
values.</p>
<p>In the context of this package, an "event" is a two-dimensional numpy array
with shape <code>(M,4)</code> where <code>M</code> is the multiplicity. An array of events is a 
three-dimensional array with shape <code>(N,M,4)</code> where <code>N</code> is the number of events.
The valid inputs and outputs of the functions here will be described using
this terminology.</p>
<hr />
<h4 id="ptyphims_from_p4s">ptyphims_from_p4s</h4>
<pre><code class="python">energyflow.ptyphims_from_p4s(p4s, phi_ref=None)
</code></pre>

<p>Convert to hadronic coordinates <code>[pt,y,phi,m]</code> from Cartesian
coordinates. All-zero four-vectors are left alone.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
<li><strong>phi_ref</strong> : {<code>None</code>, <code>'hardest'</code>, <em>float</em>, <em>numpy.ndarray</em>}<ul>
<li>Used to help deal with the fact that $\phi$ is a periodic coordinate.
If a float (which should be in $[0,2\pi)$), all phi values will be
within $\pm\pi$ of this reference value. If <code>'\hardest'</code>, the phi of
the hardest particle is used as the reference value. If <code>None</code>, all
phis will be in the range $[0,2\pi)$. An array is accepted in the case
that <code>p4s</code> is an array of events, in which case the <code>phi_ref</code> array
should have shape <code>(N,)</code> where <code>N</code> is the number of events.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of hadronic four-momenta with the same shape as the input.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="pts_from_p4s">pts_from_p4s</h4>
<pre><code class="python">energyflow.pts_from_p4s(p4s)
</code></pre>

<p>Calculate the transverse momenta of a collection of four-vectors.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of transverse momenta with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="pt2s_from_p4s">pt2s_from_p4s</h4>
<pre><code class="python">energyflow.pt2s_from_p4s(p4s)
</code></pre>

<p>Calculate the squared transverse momenta of a collection of four-vectors.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of squared transverse momenta with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="ys_from_p4s">ys_from_p4s</h4>
<pre><code class="python">energyflow.ys_from_p4s(p4s)
</code></pre>

<p>Calculate the rapidities of a collection of four-vectors. Returns zero
for all-zero particles</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of rapidities with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="etas_from_p4s">etas_from_p4s</h4>
<pre><code class="python">energyflow.etas_from_p4s(p4s)
</code></pre>

<p>Calculate the pseudorapidities of a collection of four-vectors. Returns
zero for all-zero particles</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of pseudorapidities with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="phis_from_p4s">phis_from_p4s</h4>
<pre><code class="python">energyflow.phis_from_p4s(p4s, phi_ref=None)
</code></pre>

<p>Calculate the azimuthal angles of a collection of four-vectors.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
<li><strong>phi_ref</strong> : {<em>float</em>, <em>numpy.ndarray</em>, <code>None</code>, <code>'hardest'</code>}<ul>
<li>Used to help deal with the fact that $\phi$ is a periodic coordinate.
If a float (which should be in $[0,2\pi)$), all phi values will be
within $\pm\pi$ of this reference value. If <code>'\hardest'</code>, the phi of
the hardest particle is used as the reference value. If <code>None</code>, all
phis will be in the range $[0,2\pi)$. An array is accepted in the case
that <code>p4s</code> is an array of events, in which case the <code>phi_ref</code> array
should have shape <code>(N,)</code> where <code>N</code> is the number of events.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of azimuthal angles with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="m2s_from_p4s">m2s_from_p4s</h4>
<pre><code class="python">energyflow.m2s_from_p4s(p4s)
</code></pre>

<p>Calculate the squared masses of a collection of four-vectors.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of squared masses with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="ms_from_p4s">ms_from_p4s</h4>
<pre><code class="python">energyflow.ms_from_p4s(p4s)
</code></pre>

<p>Calculate the masses of a collection of four-vectors.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>p4s</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian coordinates.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of masses with shape <code>p4s.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="ms_from_ps">ms_from_ps</h4>
<pre><code class="python">energyflow.ms_from_ps(ps)
</code></pre>

<p>Calculate the masses of a collection of Lorentz vectors in two or more
spacetime dimensions.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ps</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in Cartesian
coordinates in $d\ge2$ spacetime dimensions.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of masses with shape <code>ps.shape[:-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="etas_from_pts_ys_ms">etas_from_pts_ys_ms</h4>
<pre><code class="python">energyflow.etas_from_pts_ys_ms(pts, ys, ms)
</code></pre>

<p>Calculate pseudorapidities from transverse momenta, rapidities, and masses.
All input arrays should have the same shape.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pts</strong> : <em>numpy.ndarray</em><ul>
<li>Array of transverse momenta.</li>
</ul>
</li>
<li><strong>ys</strong> : <em>numpy.ndarray</em><ul>
<li>Array of rapidities.</li>
</ul>
</li>
<li><strong>ms</strong> : <em>numpy.ndarray</em><ul>
<li>Array of masses.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>Array of pseudorapidities with the same shape as <code>ys</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="ys_from_pts_etas_ms">ys_from_pts_etas_ms</h4>
<pre><code class="python">energyflow.ys_from_pts_etas_ms(pts, etas, ms)
</code></pre>

<p>Calculate rapidities from transverse momenta, pseudorapidities, and masses.
All input arrays should have the same shape.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pts</strong> : <em>numpy.ndarray</em><ul>
<li>Array of transverse momenta.</li>
</ul>
</li>
<li><strong>etas</strong> : <em>numpy.ndarray</em><ul>
<li>Array of pseudorapidities.</li>
</ul>
</li>
<li><strong>ms</strong> : <em>numpy.ndarray</em><ul>
<li>Array of masses.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>Array of rapidities with the same shape as <code>etas</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="p4s_from_ptyphims">p4s_from_ptyphims</h4>
<pre><code class="python">energyflow.p4s_from_ptyphims(ptyphims)
</code></pre>

<p>Calculate Cartesian four-vectors from transverse momenta, rapidities,
azimuthal angles, and (optionally) masses for each input.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphims</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in hadronic coordinates.
The mass is optional and if left out will be taken to be zero.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of Cartesian four-vectors.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="p4s_from_ptyphipids">p4s_from_ptyphipids</h4>
<pre><code class="python">energyflow.p4s_from_ptyphipids(ptyphipids, error_on_unknown=False)
</code></pre>

<p>Calculate Cartesian four-vectors from transverse momenta, rapidities,
azimuthal angles, and particle IDs for each input. The particle IDs are
used to lookup the mass of the particle. Transverse momenta should have
units of GeV when using this function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphipids</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle, event, or array of events in hadronic coordinates
where the mass is replaced by the PDG ID of the particle.</li>
</ul>
</li>
<li><strong>error_on_unknown</strong> : <em>bool</em><ul>
<li>See the corresponding argument of <a href="#pids2ms"><code>pids2ms</code></a>.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of Cartesian four-vectors with the same shape as the input.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="sum_ptyphims">sum_ptyphims</h4>
<pre><code class="python">energyflow.sum_ptyphims(ptyphims, scheme='escheme')
</code></pre>

<p>Add a collection of four-vectors that are expressed in hadronic
coordinates by first converting to Cartesian coordinates and then summing.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphims</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>An event in hadronic coordinates. The mass is optional and if left
out will be taken to be zero.</li>
</ul>
</li>
<li><strong>scheme</strong> : <em>str</em><ul>
<li>A string specifying a recombination scheme for adding four-vectors
together. Currently supported options are <code>'escheme'</code>, which adds the
vectors in Cartesian coordinates, and <code>'ptscheme'</code>, which sums the pTs
of each particle and places the jet axis at the pT-weighted centroid
in the rapidity-azimuth plane. Note that <code>'ptscheme'</code> will return a
three-vector consisting of the jet <code>[pT,y,phi]</code> with no mass value.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>Array of summed four-vectors, in hadronic coordinates.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="sum_ptyphipids">sum_ptyphipids</h4>
<pre><code class="python">energyflow.sum_ptyphipids(ptyphipids, scheme='escheme', error_on_unknown=False)
</code></pre>

<p>Add a collection of four-vectors that are expressed as
<code>[pT,y,phi,pdgid]</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphipids</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>A single particle or event in hadronic coordinates where the mass
is replaced by the PDG ID of the particle.</li>
</ul>
</li>
<li><strong>scheme</strong> : <em>str</em><ul>
<li>See the argument of the same name <a href="#sum_ptyphims"><code>here</code></a>.</li>
</ul>
</li>
<li><strong>error_on_unknown</strong> : <em>bool</em><ul>
<li>See the corresponding argument of <a href="#pids2ms"><code>pids2ms</code></a>.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>Array of summed four-vectors, in hadronic coordinates.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="center_ptyphims">center_ptyphims</h4>
<pre><code class="python">energyflow.center_ptyphims(ptyphims, axis=None, center='escheme', copy=True)
</code></pre>

<p>Center a collection of four-vectors according to a calculated or 
provided axis.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphims</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>An event in hadronic coordinates. The mass is optional and if left
out will be taken to be zero.</li>
</ul>
</li>
<li><strong>axis</strong> : <em>numpy.ndarray</em><ul>
<li>If not <code>None</code>, the <code>[y,phi]</code> values to use for centering.</li>
</ul>
</li>
<li><strong>center</strong> : <em>str</em><ul>
<li>The centering scheme to be used. Valid options are the same as the
<code>scheme</code> argument <a href="#sum_ptyphims"><code>here</code></a>.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Whether or not to copy the input array.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of hadronic four-momenta with the positions centered around
the origin.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="rotate_ptyphims">rotate_ptyphims</h4>
<pre><code class="python">energyflow.rotate_ptyphims(ptyphims, rotate='ptscheme', center=None, copy=True)
</code></pre>

<p>Rotate a collection of four-vectors to vertically align the principal
component of the energy-flow tensor. The principal component is obtained
as the eigenvector of the energy-flow tensor with the largest eigenvalue.
It is only defined up to a sign, however it is ensured that </p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>ptyphims</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>An event in hadronic coordinates. The mass is optional and if left
out will be taken to be zero.</li>
</ul>
</li>
<li><strong>rotate</strong> : <em>str</em><ul>
<li>The rotation scheme to be used. Currently, only <code>'ptscheme'</code> is
supported, which causes the rotation to take place in the 
rapidity-azimuth plane.</li>
</ul>
</li>
<li><strong>center</strong> : <em>str</em> or <code>None</code><ul>
<li>If not <code>None</code>, the event will be centered prior to rotation and this
argument will be passed on to <code>center_ptyphims</code> as the centering
scheme.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Whether or not to copy the input array.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of hadronic four-momenta with the positions rotated around
the origin.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="reflect_ptyphims">reflect_ptyphims</h4>
<pre><code class="python">energyflow.reflect_ptyphims(ptyphims, which='both', center=None, copy=True)
</code></pre>

<hr />
<h4 id="pids2ms">pids2ms</h4>
<pre><code class="python">energyflow.pids2ms(pids, error_on_unknown=False)
</code></pre>

<p>Map an array of <a href="http://pdg.lbl.gov/2018/
reviews/rpp2018-rev-monte-carlo-numbering.pdf">Particle Data Group IDs</a> to an array of the
corresponding particle masses (in GeV).</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pids</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>An array of numeric (float or integer) PDG ID values.</li>
</ul>
</li>
<li><strong>error_on_unknown</strong> : <em>bool</em><ul>
<li>Controls whether a <code>KeyError</code> is raised if an unknown PDG ID is
encountered. If <code>False</code>, unknown PDG IDs will map to zero.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of masses in GeV.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="pids2chrgs">pids2chrgs</h4>
<pre><code class="python">energyflow.pids2chrgs(pids, error_on_unknown=False)
</code></pre>

<p>Map an array of <a href="http://pdg.lbl.gov/2018/
reviews/rpp2018-rev-monte-carlo-numbering.pdf">Particle Data Group IDs</a> to an array of the
corresponding particle charges (in fundamental units where the charge
of the electron is -1).</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>pids</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>An array of numeric (float or integer) PDG ID values.</li>
</ul>
</li>
<li><strong>error_on_unknown</strong> : <em>bool</em><ul>
<li>Controls whether a <code>KeyError</code> is raised if an unknown PDG ID is
encountered. If <code>False</code>, unknown PDG IDs will map to zero.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of charges as floats.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="ischrgd">ischrgd</h4>
<pre><code class="python">energyflow.ischrgd(pids, ignored_pids=None)
</code></pre>

<hr />
<h4 id="phi_fix">phi_fix</h4>
<pre><code class="python">energyflow.phi_fix(phis, phi_ref, copy=True)
</code></pre>

<p>A function to ensure that all phis are within $\pi$ of <code>phi_ref</code>. It is
assumed that all starting phi values are $\pm 2\pi$ of <code>phi_ref</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>phis</strong> : <em>numpy.ndarray</em> or <em>list</em><ul>
<li>Array of phi values.</li>
</ul>
</li>
<li><strong>phi_ref</strong> : {<em>float</em> or <em>numpy.ndarray</em>}<ul>
<li>A reference value used so that all phis will be within $\pm\pi$ of
this value. Should have a shape of <code>phis.shape[:-1]</code>.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Determines if <code>phis</code> are copied or not. If <code>False</code> then <code>phis</code> is
modified in place.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An array of the fixed phi values.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="flat_metric">flat_metric</h4>
<pre><code class="python">energyflow.flat_metric(dim)
</code></pre>

<p>The Minkowski metric in <code>dim</code> spacetime dimensions in the mostly-minus
convention.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>dim</strong> : <em>int</em><ul>
<li>The number of spacetime dimensions (thought to be four in our 
universe).</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>1-d numpy.ndarray</em><ul>
<li>A <code>dim</code>-length, one-dimensional (not matrix) array equal to 
<code>[+1,-1,...,-1]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="random-events">Random Events</h3>
<p>Functions to generate random sets of four-vectors. Includes an implementation
of the <a href="https://doi.org/10.1016/0010-4655(86)90119-0">RAMBO</a> algorithm for
sampling uniform M-body massless phase space. Also includes other functions for
various random, non-center of momentum, and non-uniform sampling.</p>
<hr />
<h4 id="gen_random_events">gen_random_events</h4>
<pre><code class="python">energyflow.gen_random_events(nevents, nparticles, dim=4, mass=0.0)
</code></pre>

<p>Generate random events with a given number of particles in a given
spacetime dimension. The spatial components of the momenta are
distributed uniformly in $[-1,+1]$. These events are not guaranteed to 
uniformly sample phase space.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>nevents</strong> : <em>int</em><ul>
<li>Number of events to generate.</li>
</ul>
</li>
<li><strong>nparticles</strong> : <em>int</em><ul>
<li>Number of particles in each event.</li>
</ul>
</li>
<li><strong>dim</strong> : <em>int</em><ul>
<li>Number of spacetime dimensions.</li>
</ul>
</li>
<li><strong>mass</strong> : <em>float</em> or <code>'random'</code><ul>
<li>Mass of the particles to generate. Can be set to <code>'random'</code> to obtain
a different random mass for each particle.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An <code>(nevents,nparticles,dim)</code> array of events. The particles 
are specified as <code>[E,p1,p2,...]</code>. If <code>nevents</code> is 1 then that axis is
dropped.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="gen_random_events_mcom">gen_random_events_mcom</h4>
<pre><code class="python">energyflow.gen_random_events_mcom(nevents, nparticles, dim=4)
</code></pre>

<p>Generate random events with a given number of massless particles in a
given spacetime dimension. The total momentum are made to sum
to zero. These events are not guaranteed to uniformly sample phase space.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>nevents</strong> : <em>int</em><ul>
<li>Number of events to generate.</li>
</ul>
</li>
<li><strong>nparticles</strong> : <em>int</em><ul>
<li>Number of particles in each event.</li>
</ul>
</li>
<li><strong>dim</strong> : <em>int</em><ul>
<li>Number of spacetime dimensions.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An <code>(nevents,nparticles,dim)</code> array of events. The particles 
are specified as <code>[E,p1,p2,...]</code>.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="gen_massless_phase_space">gen_massless_phase_space</h4>
<pre><code class="python">energyflow.gen_massless_phase_space(nevents, nparticles, energy=1.0)
</code></pre>

<p>Implementation of the <a href="https://doi.org/10.1016/0010-4655(86)90119-0">RAMBO</a>
algorithm for uniformly sampling massless M-body phase space for any center
of mass energy.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>nevents</strong> : <em>int</em><ul>
<li>Number of events to generate.</li>
</ul>
</li>
<li><strong>nparticles</strong> : <em>int</em><ul>
<li>Number of particles in each event.</li>
</ul>
</li>
<li><strong>energy</strong> : <em>float</em><ul>
<li>Total center of mass energy of each event.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>numpy.ndarray</em><ul>
<li>An <code>(nevents,nparticles,4)</code> array of events. The particles 
are specified as <code>[E,p_x,p_y,p_z]</code>. If <code>nevents</code> is 1 then that axis is
dropped.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="data-tools">Data Tools</h3>
<p>Functions for dealing with datasets. These are not importable from
the top level <code>energyflow</code> module, but must instead be imported 
from <code>energyflow.utils</code>.</p>
<hr />
<h4 id="get_examples">get_examples</h4>
<pre><code class="python">energyflow.utils.get_examples(path='~/.energyflow', which='all', overwrite=False)
</code></pre>

<p>Pulls examples from GitHub. To ensure availability of all examples
update EnergyFlow to the latest version.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>path</strong> : <em>str</em><ul>
<li>The destination for the downloaded files. Note that <code>examples</code>
is automatically appended to the end of this path.</li>
</ul>
</li>
<li><strong>which</strong> : {<em>list</em>, <code>'all'</code>}<ul>
<li>List of examples to download, or the string <code>'all'</code> in which 
case all the available examples are downloaded.</li>
</ul>
</li>
<li><strong>overwrite</strong> : <em>bool</em><ul>
<li>Whether to overwrite existing files or not.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="data_split">data_split</h4>
<pre><code class="python">energyflow.utils.data_split(*args, train=-1, val=0.0, test=0.1, shuffle=True)
</code></pre>

<p>A function to split a dataset into train, test, and optionally 
validation datasets.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*args</strong> : arbitrary <em>numpy.ndarray</em> datasets<ul>
<li>An arbitrary number of datasets, each required to have
the same number of elements, as numpy arrays.</li>
</ul>
</li>
<li><strong>train</strong> : {<em>int</em>, <em>float</em>}<ul>
<li>If a float, the fraction of elements to include in the training
set. If an integer, the number of elements to include in the
training set. The value <code>-1</code> is special and means include the
remaining part of the dataset in the training dataset after
the test and (optionally) val parts have been removed</li>
</ul>
</li>
<li><strong>val</strong> : {<em>int</em>, <em>float</em>}<ul>
<li>If a float, the fraction of elements to include in the validation
set. If an integer, the number of elements to include in the
validation set. The value <code>0</code> is special and means do not form
a validation set.</li>
</ul>
</li>
<li><strong>test</strong> : {<em>int</em>, <em>float</em>}<ul>
<li>If a float, the fraction of elements to include in the test
set. If an integer, the number of elements to include in the
test set.</li>
</ul>
</li>
<li><strong>shuffle</strong> : <em>bool</em><ul>
<li>A flag to control whether the dataset is shuffle prior to 
being split into parts.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>list</em><ul>
<li>A list of the split datasets in train, [val], test order. If 
datasets <code>X</code>, <code>Y</code>, and <code>Z</code> were given as <code>args</code> (and assuming a
non-zero <code>val</code>), then [<code>X_train</code>, <code>X_val</code>, <code>X_test</code>, <code>Y_train</code>, 
<code>Y_val</code>, <code>Y_test</code>, <code>Z_train</code>, <code>Z_val</code>, <code>Z_test</code>] will be returned.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="to_categorical">to_categorical</h4>
<pre><code class="python">energyflow.utils.to_categorical(labels, num_classes=None)
</code></pre>

<p>One-hot encodes class labels.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>labels</strong> : <em>1-d numpy.ndarray</em><ul>
<li>Labels in the range <code>[0,num_classes)</code>.</li>
</ul>
</li>
<li><strong>num_classes</strong> : {<em>int</em>, <code>None</code>}<ul>
<li>The total number of classes. If <code>None</code>, taken to be the 
maximum label plus one.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>2-d numpy.ndarray</em><ul>
<li>The one-hot encoded labels.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="remap_pids">remap_pids</h4>
<pre><code class="python">energyflow.utils.remap_pids(events, pid_i=3)
</code></pre>

<p>Remaps PDG id numbers to small floats for use in a neural network.
<code>events</code> are modified in place and nothing is returned.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>events</strong> : <em>3-d numpy.ndarray</em><ul>
<li>The events as an array of arrays of particles.</li>
</ul>
</li>
<li><strong>pid_i</strong> : <em>int</em><ul>
<li>The index corresponding to pid information along the last 
axis of <code>events</code>.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="image-tools">Image Tools</h3>
<p>Functions for dealing with image representations of events. These are 
not importable from the top level <code>energyflow</code> module, but must 
instead be imported from <code>energyflow.utils</code>.</p>
<hr />
<h4 id="pixelate">pixelate</h4>
<pre><code class="python">energyflow.utils.pixelate(jet, npix=33, img_width=0.8, nb_chan=1, norm=True, charged_counts_only=False)
</code></pre>

<p>A function for creating a jet image from an array of particles.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>jet</strong> : <em>numpy.ndarray</em><ul>
<li>An array of particles where each particle is of the form 
<code>[pt,y,phi,pid]</code> where the particle id column is only 
used if <code>nb_chan=2</code> and <code>charged_counts_only=True</code>.</li>
</ul>
</li>
<li><strong>npix</strong> : <em>int</em><ul>
<li>The number of pixels on one edge of the jet image, which is
taken to be a square.</li>
</ul>
</li>
<li><strong>img_width</strong> : <em>float</em><ul>
<li>The size of one edge of the jet image in the rapidity-azimuth
plane.</li>
</ul>
</li>
<li><strong>nb_chan</strong> : {<code>1</code>, <code>2</code>}<ul>
<li>The number of channels in the jet image. If <code>1</code>, then only a
$p_T$ channel is constructed (grayscale). If <code>2</code>, then both a 
$p_T$ channel and a count channel are formed (color).</li>
</ul>
</li>
<li><strong>norm</strong> : <em>bool</em><ul>
<li>Whether to normalize the $p_T$ pixels to sum to <code>1</code>.</li>
</ul>
</li>
<li><strong>charged_counts_only</strong> : <em>bool</em><ul>
<li>If making a count channel, whether to only include charged 
particles. Requires that <code>pid</code> information be given.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>3-d numpy.ndarray</em><ul>
<li>The jet image as a <code>(nb_chan, npix, npix)</code> array.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="standardize">standardize</h4>
<pre><code class="python">energyflow.utils.standardize(*args, channels=None, copy=False, reg=10**-10)
</code></pre>

<p>Normalizes each argument by the standard deviation of the pixels in 
arg[0]. The expected use case would be <code>standardize(X_train, X_val, X_test)</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*args</strong> : arbitrary <em>numpy.ndarray</em> datasets<ul>
<li>An arbitrary number of datasets, each required to have
the same shape in all but the first axis.</li>
</ul>
</li>
<li><strong>channels</strong> : <em>int</em><ul>
<li>A list of which channels (assumed to be the second axis)
to standardize. <code>None</code> is interpretted to mean every channel.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Whether or not to copy the input arrays before modifying them.</li>
</ul>
</li>
<li><strong>reg</strong> : <em>float</em><ul>
<li>Small parameter used to avoid dividing by zero. It's important
that this be kept consistent for images used with a given model.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>list</em> <ul>
<li>A list of the now-standardized arguments.</li>
</ul>
</li>
</ul>
<hr />
<h4 id="zero_center">zero_center</h4>
<pre><code class="python">energyflow.utils.zero_center(args, kwargs)
</code></pre>

<p>Subtracts the mean of arg[0] from the arguments. The expected 
use case would be <code>standardize(X_train, X_val, X_test)</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><strong>*args</strong> : arbitrary <em>numpy.ndarray</em> datasets<ul>
<li>An arbitrary number of datasets, each required to have
the same shape in all but the first axis.</li>
</ul>
</li>
<li><strong>channels</strong> : <em>int</em><ul>
<li>A list of which channels (assumed to be the second axis)
to zero center. <code>None</code> is interpretted to mean every channel.</li>
</ul>
</li>
<li><strong>copy</strong> : <em>bool</em><ul>
<li>Whether or not to copy the input arrays before modifying them.</li>
</ul>
</li>
</ul>
<p><strong>Returns</strong></p>
<ul>
<li><em>list</em> <ul>
<li>A list of the zero-centered arguments.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="fastjet-tools">FastJet Tools</h3>
<hr />
<h4 id="pjs_from_ptyphims">pjs_from_ptyphims</h4>
<pre><code class="python">energyflow.utils.pjs_from_ptyphims(ptyphims)
</code></pre>

<hr />
<h4 id="cluster">cluster</h4>
<pre><code class="python">energyflow.utils.cluster(pjs, algorithm='ca', R=1000.0)
</code></pre>

<hr />
<h4 id="softdrop">softdrop</h4>
<pre><code class="python">energyflow.utils.softdrop(jet, zcut=0.1, beta=0, R=1.0)
</code></pre>

<hr />
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../obs/" class="btn btn-neutral" title="Observables"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/pkomiske/EnergyFlow/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../obs/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
      <script src="../../js/eftheme.js" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
